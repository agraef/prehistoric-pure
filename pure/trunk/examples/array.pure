/* array.pure: integer-indexed arrays implemented as size-balanced
   binary trees. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   This script implements an efficient variable-sized array data structure
   which allows to access and update individual array members, as well as
   to add and remove elements at the beginning and end of an array. All these
   operations are carried out in logarithmic time. The implementation is
   based on the same ideas as in Frank Drewes' queue data structure.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


/*****************************************************************************/
/*                                                                           */
/*                     DIFFERENCES VERSUS Q LANGUAGE                         */
/*                                                                           */
/******************************************************************************

   Views are not currently available in Pure and so the data structures are
   displayed as they really are. To view the data as lists you should call
   the function "members".

******************************************************************************/


/*** some declarations ***/

using primitives;

// empty tree constructor
nullary nil;


/******************************************************************************/
/*                                                                            */
/*                               PUBLIC FUNCTIONS                             */
/*                                                                            */
/******************************************************************************/


/*** The following functions represent the user's interface to the module ***/


// array type check
isarray (tarray _)		= 1;
isarray _			= 0;


// create an empty array
emptyarray			= tarray nil;


// create an array from a list
array xs
	= tarray (foldl tarray_append nil xs)
		if listp xs;


// create a two-dimensional array from a two-dimensional list
array2 xs			= array (map array xs);


// create an array of a given size filled with a constant value
mkarray x n::int
	= tarray (mkarray_ x n)
		with
			mkarray_ x n::int	= nil if n <= 0;
						= tip x if n == 1;
						= tarray_mkbin (n mod 2)
						  (mkarray_ x (n - n div 2))
						  (mkarray_ x (n div 2))
		end;

// create two-dimensional array of given dimensions filled with a constant value
mkarray2 x (n::int, m::int)	= mkarray (mkarray x m) n;


// get array size
#(tarray a)
	= size a
		with
			size nil		= 0;
			size (tip _)		= 1;
			size (bin 0 a1 _)	= (size a1) * 2;
			size (bin 1 a1 _)	= (size a1) * 2 - 1
		end;


// get value by index
(tarray a)!i::int
	= ith a i
		with
			ith (tip x) 0	= x;
			ith (bin _ a1 a2) i::int
					= ith a1 (i div 2) if i mod 2 == 0;
					= ith a2 (i div 2) if i mod 2 == 1;
			ith _ _		= throw out_of_bounds
		end;


// get value by indices from two-dimensional array
x@(tarray _)!(i::int, j::int)	= (x!i)!j;


// check for an empty array
null (tarray nil)		= 1;
null (tarray _)			= 0;


// get all array members in a list form
members (tarray a)
	= members_ a
		with
			members_ nil		= [];
			members_ (tip x)	= [x];
			members_ (bin _ a1 a2)
				= tarray_merge (members_ a1)
					       (members_ a2)
		end;


// get all members of an two-dimensional array in a list form
members2 x@(tarray _)		= map members (members x);


// get the first array member
first (tarray a)
	= tarray_first a
		with
			first_ (tip x)		= x;
			first_ (bin _ a1 _)	= first_ a1
		end;


// get the last array member
last (tarray a)
	= last_ a
		with
			last_ (tip x)		= x;
			last_ (bin 0 _ a2)	= last_ a2;
			last_ (bin 1 a1 _)	= last_ a1
		end;


// remove the first member from an array
rmfirst (tarray a)
	= tarray (rmfirst_ a)
		with
			rmfirst_ (tip _)	= nil;
			rmfirst_ (bin 0 a1 a2)
				= tarray_mkbin 1 a2 (rmfirst_ a1);
			rmfirst_ (bin 1 a1 a2)
				= tarray_mkbin 0 a2 (rmfirst_ a1)
		end;


// remove the last member from an array
rmlast (tarray a)
	= tarray (rmlast_ a)
		with
			rmlast_ (tip _)		= nil;
			rmlast_ (bin 0 a1 a2)
				= tarray_mkbin 1 a1 (rmlast_ a2);
			rmlast_ (bin 1 a1 a2)
				= tarray_mkbin 0 (rmlast_ a1) a2
		end;


// insert a new member at the array beginning
insert (tarray a) y
	= tarray (insert_ a y)
		with
			insert_ nil y		= tip y;
			insert_ (tip x) y	= bin 0 (tip y) (tip x);
			insert_ (bin 0 a1 a2) y
				= tarray_mkbin 1 (insert_ a2 y) a1;
			insert_ (bin 1 a1 a2) y
				= tarray_mkbin 0 (insert_ a2 y) a1
		end;


// append a new member at the array end
append (tarray a) y
	= tarray (tarray_append a y);


//update a given array position with a new value
update (tarray a) i::int y
	= tarray (update_ a i y)
		with
			update_ (tip _) 0 y	= tip y;
			update_ (bin b a1 a2) i::int y
				= bin b (update_ a1 (i div 2) y) a2
				      if i mod 2 == 0;
				= bin b a1 (update_ a2 (i div 2) y)
				      if i mod 2 == 1
		end;


//update a given position of a two-dimensional array with a new value
update2 x@(tarray a) (i::int, j::int) y
				= update x i (update (x!i) j y);


/* test for equality of two arrays */
(tarray a) == (tarray b)
	= eq a b
		with
			eq nil nil			= 1;
			eq nil  (tip _)			= 0;
			eq nil  (bin _ _ _)		= 0;
			eq (tip _) nil			= 0;
			eq (tip x) (tip y)		= (x == y);
			eq (tip _) (bin _ _ _)		= 0;
			eq (bin _ _ _) nil		= 0;
			eq (bin _ _ _) (tip _)		= 0;
			eq (bin b1 a1 a2)  (bin b2 a3 a4)
					= if (b1 != b2)
						then 0
						else if (a1 != a3)
							then 0
							else (a2 == a4)
		end;


/* test for inequality of two arrays */
(tarray a) != (tarray b)
	= neq a b
		with
			neq nil nil		= 0;
			neq nil (tip _)		= 1;
			neq nil (bin _ _ _)	= 1;
			neq (tip _) nil		= 1;
			neq (tip x) (tip y)	= (x != y);
			neq (tip _) (bin _ _ _)	= 1;
			neq (bin _ _ _) nil	= 1;
			neq (bin _ _ _) (tip _)	= 1;
			neq (bin b1 a1 a2) (bin b2 a3 a4)
					= if (b1 != b2)
						then 1
						else if (a1 != a3)
							then 1
							else (a2 != a4)
		end;


/******************************************************************************/
/*                                                                            */
/*                              PRIVATE FUNCTIONS                             */
/*                                                                            */
/******************************************************************************/

/*** The following functions shouldn't be directly used by users ***/


// construct a binary array node

tarray_mkbin _ nil a2		= a2;
tarray_mkbin _ a1 nil		= a1;
tarray_mkbin b a1 a2		= bin b a1 a2;


// merge lists xs (even elements) and ys
// (odd elements)

tarray_merge [] ys		= ys;
tarray_merge (x:xs) ys		= (x:tarray_merge ys xs);

// append stuff - this is reused

tarray_append nil y		= tip y;
tarray_append (tip x) y		= bin 0 (tip x) (tip y);
tarray_append (bin 0 a1 a2) y	= tarray_mkbin 1 (tarray_append a1 y) a2;
tarray_append (bin 1 a1 a2) y	= tarray_mkbin 0 a1 (tarray_append a2 y);
