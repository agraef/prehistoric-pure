/* array.pure: integer-indexed arrays implemented as size-balanced
   binary trees. */

/* Copyright (c) 2008 by Albert Graef <Dr.Graef@t-online.de>.

   This file is part of the Pure programming language and system.

   Pure is free software: you can redistribute it and/or modify it under the
   terms of the GNU General Public License as published by the Free Software
   Foundation, either version 3 of the License, or (at your option) any later
   version.

   Pure is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
   details.

   You should have received a copy of the GNU General Public License along
   with this program.  If not, see <http://www.gnu.org/licenses/>. */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   This script implements an efficient variable-sized array data structure
   which allows to access and update individual array members, as well as
   to add and remove elements at the beginning and end of an array. All these
   operations are carried out in logarithmic time. The implementation is
   based on the same ideas as in Frank Drewes' queue data structure.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


/*****************************************************************************/
/*                                                                           */
/*                     DIFFERENCES VERSUS Q LANGUAGE                         */
/*                                                                           */
/******************************************************************************

   Views are not currently available in Pure and so the data structures are
   displayed as they really are. To view the data as lists you should call
   the function "members".

******************************************************************************/


/*** some declarations ***/

using primitives;

// module name constructor
nullary tarray;

// tree constructors
nullary nil bin tip;


/******************************************************************************/
/*                                                                            */
/*                               PUBLIC FUNCTIONS                             */
/*                                                                            */
/******************************************************************************/


/*** The following functions represent the user's interface to the module ***/


// array type check
isarray (tarray _)		= 1;
isarray _			= 0;


// create an empty array
emptyarray			= tarray nil;


// create an array from a list
array Xs			= tarray (tarray_array Xs);


// create a two-dimensional array from a two-dimensional list
array2 Xs			= array (map array Xs);


// create an array of a given size filled with a constant value
mkarray X N::int		= tarray (tarray_mkarray X N);


// create two-dimensional array of given dimensions filled with a constant value
mkarray2 X (N::int, M::int)	= mkarray (mkarray X M) N;


// get array size
#(tarray A)			= tarray_size A;


// get value by index
(tarray A)!I::int		= tarray_ith A I;


// get value by indices from two-dimensional array
X@(tarray A)!(I::int, J::int)	= (X!I)!J;


// check for an empty array
null (tarray nil)		= 1;
null (tarray _)			= 0;


// get all array members in a list form
members (tarray A)		= tarray_members A;


// get all members of an two-dimensional array in a list form
members2 X@(tarray A)		= map members (members X);


// get the first array member
first (tarray A)		= tarray_first A;


// get the last array member
last (tarray A)			= tarray_last A;


// remove the first member from an array
rmfirst (tarray A)		= tarray (tarray_rmfirst A);


// remove the last member from an array
rmlast (tarray A)		= tarray (tarray_rmlast A);


// insert a new member at the array beginning
insert (tarray A) Y		= tarray (tarray_insert A Y);


// append a new member at the array end
append (tarray A) Y		= tarray (tarray_append A Y);


//update a given array position with a new value
update (tarray A) I::int Y	= tarray (tarray_update A I Y);


//update a given position of a two-dimensional array with a new value
update2 X@(tarray A) (I::int, J::int) Y
				= update X I (update (X!I) J Y);


/* test for equality of two arrays */
(tarray A) == (tarray B)	= tarray_eq A B;


/* test for inequality of two arrays */
(tarray A) != (tarray B)	= tarray_neq A B;



/******************************************************************************/
/*                                                                            */
/*                              PRIVATE FUNCTIONS                             */
/*                                                                            */
/******************************************************************************/

/*** The following functions shouldn't be directly used by users ***/


// construct a binary array node

tarray_mkbin _ nil A2		= A2;
tarray_mkbin _ A1 nil		= A1;
tarray_mkbin B A1 A2		= bin B A1 A2;


// merge lists Xs (even elements) and Ys
// (odd elements)

tarray_merge [] Ys		= Ys;
tarray_merge (X:Xs) Ys		= (X:tarray_merge Ys Xs);


// array stuff
tarray_array Xs			= foldl tarray_append nil Xs if listp Xs;


// mkarray stuff
tarray_mkarray X N::int		= nil if N <= 0;
				= tip X if N == 1;
				= tarray_mkbin (N mod 2)
				  (tarray_mkarray X (N - N div 2))
				  (tarray_mkarray X (N div 2));


// array size stuff
tarray_size nil			= 0;
tarray_size (tip _)		= 1;
tarray_size (bin 0 A1 _)	= (tarray_size A1) * 2;
tarray_size (bin 1 A1 _)	= (tarray_size A1) * 2 - 1;


// get value by index stuff
tarray_ith (tip X) 0		= X;
tarray_ith (bin _ A1 A2) I::int	= tarray_ith A1 (I div 2) if I mod 2 == 0;
				= tarray_ith A2 (I div 2) if I mod 2 == 1;

// members stuff
tarray_members nil		= [];
tarray_members (tip X)		= [X];
tarray_members (bin _ A1 A2)	= tarray_merge (tarray_members A1)
					       (tarray_members A2);


// first stuff
tarray_first (tip X)		= X;
tarray_first (bin _ A1 _)	= tarray_first A1;


// last stuff
tarray_last (tip X)		= X;
tarray_last (bin 0 _ A2)	= tarray_last A2;
tarray_last (bin 1 A1 _)	= tarray_last A1;


// remove first stuff
tarray_rmfirst (tip _)		= nil;
tarray_rmfirst (bin 0 A1 A2)	= tarray_mkbin 1 A2 (tarray_rmfirst A1);
tarray_rmfirst (bin 1 A1 A2)	= tarray_mkbin 0 A2 (tarray_rmfirst A1);


// remove last stuff
tarray_rmlast (tip _)		= nil;
tarray_rmlast (bin 0 A1 A2)	= tarray_mkbin 1 A1 (tarray_rmlast A2);
tarray_rmlast (bin 1 A1 A2)	= tarray_mkbin 0 (tarray_rmlast A1) A2;


// insert stuff
tarray_insert nil Y		= tip Y;
tarray_insert (tip X) Y		= bin 0 (tip Y) (tip X);
tarray_insert (bin 0 A1 A2) Y	= tarray_mkbin 1 (tarray_insert A2 Y) A1;
tarray_insert (bin 1 A1 A2) Y	= tarray_mkbin 0 (tarray_insert A2 Y) A1;


// append stuff
tarray_append nil Y		= tip Y;
tarray_append (tip X) Y		= bin 0 (tip X) (tip Y);
tarray_append (bin 0 A1 A2) Y	= tarray_mkbin 1 (tarray_append A1 Y) A2;
tarray_append (bin 1 A1 A2) Y	= tarray_mkbin 0 A1 (tarray_append A2 Y);


// update stuff
tarray_update (tip _) 0 Y	= tip Y;
tarray_update (bin B A1 A2) I::int Y
				= bin B (tarray_update A1 (I div 2) Y) A2
				      if I mod 2 == 0;
				= bin B A1 (tarray_update A2 (I div 2) Y)
				      if I mod 2 == 1;


// equlity test stuff
tarray_eq nil nil		= 1;
tarray_eq nil  (tip _)		= 0;
tarray_eq nil  (bin _ _ _)	= 0;
tarray_eq (tip _) nil		= 0;
tarray_eq (tip X) (tip Y)	= (X == Y);
tarray_eq (tip _) (bin _ _ _)	= 0;
tarray_eq (bin _ _ _) nil	= 0;
tarray_eq (bin _ _ _) (tip _)	= 0;
tarray_eq (bin B1 A1 A2)  (bin B2 A3 A4)
				= if (B1 != B2)
					then 0
					else if (A1 != A3)
						then 0
						else (A2 == A4);

//inequality test stuff
tarray_neq nil nil		= 0;
tarray_neq nil (tip _)		= 1;
tarray_neq nil (bin _ _ _)	= 1;
tarray_neq (tip _) nil		= 1;
tarray_neq (tip X) (tip Y)	= (X != Y);
tarray_neq (tip _) (bin _ _ _)	= 1;
tarray_neq (bin _ _ _) nil	= 1;
tarray_neq (bin _ _ _) (tip _)	= 1;
tarray_neq (bin B1 A1 A2) (bin B2 A3 A4)
				= if (B1 != B2)
					then 1
					else if (A1 != A3)
						then 1
						else (A2 != A4);
