/* New Calendar and Clock 
   Copyright (c) 2008 by Libor Spacek

   Usage: pure -x date.pure [-h]

   Discrepancies with your local clock may occur when C library's time(); 
   returns Posix time based on UTC (Universal Temps Coordinat) or TAI
   (Temps Atomique International) rather than local daylight saving time */

using system;      // this is needed just to get C printf
extern int time(); // makes available the C function time();

puts "****************************************************************";
puts "*    New Calendar/Clock, Copyright (c) 2008 by Libor Spacek    *";
puts "****************************************************************";
def posixepoch = (12:17:16:7:5); // Mayan long count date of the posix epoch
def epochday   = mayan2days posixepoch; // (mayan) day of the posix epoch
def endofcycle = (13:0:0:0:0);   // The end of the cycle 
def cycledays  = mayan2days endofcycle; // total days in 13 Baktuns
def secsinday  = 86400.0;       // number of seconds in a day
def trueyear =  31556941;// (in seconds) divisible by 13 = current true year
def myyear   =  31556943;// div by 2277, secsinday compatible, 365.2424 days
def gregyear =  31556952;// div by 40824, mean gregorian year, 365.2425 days
def lunarmonth = 2551443;  // lunar (synodic) month to the nearest second
def newmoonsecs = dhms2secs(14063:2:19:0); // 3rd July 08 new moon in posix
   
// current values in posix time supplied by C time();
posixsecsnow = time; // int -  each new call refreshes to the current second
secsnow = posixsecsnow mod (int secsinday); // int seconds since midnight
moonphase = 100.0*((posixsecsnow-newmoonsecs) mod lunarmonth)/lunarmonth;

// first some simple conversions
secs2days s::int | secs2days s::bigint | secs2days s::double = (s / secsinday);
days2secs d::int = secsinday * d;
days2hours d::int = 24*d;
hours2days h::int = h div 24;

// conversions from/to days:hours:minutes:seconds format
// seconds can be int or bigint or double. d,h,m are ints
dhms2secs (d::int:h::int:m::int:s::int) |
dhms2secs (d::int:h::int:m::int:s::bigint) |
dhms2secs (d::int:h::int:m::int:s::double) = 60*(60*(24*d+h)+m)+s;
   
secs2dhms secs::int | secs2dhms secs::bigint | secs2dhms secs::double =
   d:(h mod 24):(m mod 60):(secs-60*m)
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
        d::int = h div 24 
   end;
   
// an arbitrary binary operator applied to two (days:hours:minutes:seconds) 
opdhms op (d1::int:h1::int:m1::int:s1)(d2::int:h2::int:m2::int:s2) =
   secs2dhms (op (dhms2secs (d1:h1:m1:s1)) (dhms2secs (d2:h2:m2:s2)));
      
// conversions from/to hours:minutes:seconds format for displaying time of day.
// hours may be more than 24 but use d:h:m:s for longer periods of time
hms2secs (h::int:m::int:s::int) |
hms2secs (h::int:m::int:s::bigint) |
hms2secs (h::int:m::int:s::double) = 60*(60*h+m)+s;
   
secs2hms secs::int | secs2hms secs::bigint | secs2hms secs::double = 
   h:(m mod 60):(secs-60*m)
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
   end;
   
// New Time Format! hours:3mins:10secs:secs = hours:tres:dicis:secs = h:t:d:s
// the normal seconds are now just a single digit 0-9
// dicis:secs are easy to read: 6:0 means 60 seconds, 12:5 125 seconds etc.
// tres - multiply by three to get traditional babylonian minutes
// hours as usual (24 hour clock)
htds2secs (h::int:t::int:d::int:s::int) = 10*(18*(20*h+t)+d)+s;
   
secs2htds secs::int | secs2htds secs::bigint | secs2htds secs::double =
   h:(t mod 20):(d mod 18):(secs-10*d)
   when 
        d::int = int (secs / 10);
        t::int = d div 18; 
        h::int = t div 20 
   end;

// not used yet but could be, as in: addmayan posixepoch (days2mayan posixdays)
addmayan (baktun1::int:katun1::int:tun1::int:vinal1::int:kin1::int)
   	   (baktun2::int:katun2::int:tun2::int:vinal2::int:kin2::int) =
   baktun:(katun mod 20):(tun mod 20):(vinal mod 18):(kin mod 20) 
   when 
   kin = kin1+kin2; vinal = vinal1+vinal2+(kin div 20); 
   tun = tun1+tun2+(vinal div 18); katun = katun1+katun2+(tun div 20);
   baktun = baktun1+baktun2+(katun div 20) 
   end;
   
days2mayan d::int = baktun:(katun mod 20):(tun mod 20):(vinal mod 18):(d mod 20)
   when 
   vinal =d div 20; tun =vinal div 18; katun =tun div 20; baktun =katun div 20
   end;

mayan2days (baktun::int:katun::int:tun::int:vinal::int:kin::int) = 
   20*(18*(20*(20*baktun+katun)+tun)+vinal)+kin;

// for now, let's just do some simple calculations to print
daytoday = epochday + (secs2days posixsecsnow);  // mayan whole day count
mayantoday = days2mayan (int daytoday); // as above but in the long count format
daysleft = cycledays - epochday - (secs2days (double posixsecsnow)); // double
mayanleft = days2mayan ((int daysleft));
timeleft = secs2htds ((int secsinday) - secsnow);
percentcomplete = 100.0*(epochday+posixsecsnow/secsinday)/cycledays;

usage = puts "Usage:  pure -x date.pure [anyarg]" $
        puts "\tanyarg for help";

case argc of 
  1 =  void (printf "\t\tThe moonphase now is: %7.4f%%\n" moonphase) $
  void (printf "Mayan day %d + UTC Time %s = %s,%s\n" ((int daytoday),
         (str (secs2hms secsnow)),(str mayantoday),(str (secs2htds secsnow))))$ 
  void (printf "Long countdown: %f days left =    %s,%s\n" 
         (daysleft, (str mayanleft), (str timeleft))) $
  void (printf "The Mayan cycle of over 5125 years is now %11.8f%% complete\n" 
         percentcomplete ) $
  void (puts"****************************************************************");
  2 = 
  void(puts "Mayan long count digits (and their range of values):") $
  void(puts "Baktun(0-12) : Katun(0-19) : Tun(0-19) : Vinal(0-17) : Kin(0-19)")$
  puts "Baktun=144000days Katun=7200days Tun=360days Vinal=20days Kin=day"$
  void (puts "\nNew clock digits (and their range of values):") $
  void (puts "Hour(0-23) : Tre(0-19) : Dici(0-17) : Sec(0-9)")$
  puts "Hour=3600secs Tre=180secs Dici=10secs Sec=second\n"$
  puts "Complete time count: Baktun:Katun:Tun:Vinal:Kin,Hour:Tre:Dici:Sec\n" $
  usage;
  n = usage otherwise
end;
