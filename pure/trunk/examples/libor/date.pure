/* New Calendar and Clock 
   Copyright (c) 2008 by Libor Spacek

   Usage: pure -x date.pure [-h]

   Discrepancies with your local clock may occur when C library's time(); 
   returns Posix time based on UTC (Universal Temps Coordinat) or TAI
   (Temps Atomique International) rather than local daylight saving time */

using system;      // this is needed just to get C printf
extern int time(); // makes available the C function time();

puts "****************************************************************";
puts "*    New Calendar/Clock, Copyright (c) 2008 by Libor Spacek    *";
puts "****************************************************************";
def posixepoch = (12:17:16:7:5); // Mayan long count date of the posix epoch
def endofcycle = (13:0:0:0:0);   // The end of the cycle 
def secsinday  = 86400;          // number of seconds in a day
def trueyear =  31556941;// (in seconds) divisible by 13 = current true year
def myyear   =  31556943;// div by 2277, secsinday compatible, 365.2424 days
def gregyear =  31556952;// div by 40824, mean gregorian year, 365.2425 days
def lunarmonth = 2551443;  // lunar (synodic) month to the nearest second
def newmoondhms = (14063:2:19:0); // 3rd July 08 new moon in posix dhms
   
// current values in posix time supplied by C time();
posixsecsnow = time; // int -  each new call refreshes to the current second
secsnow = posixsecsnow mod secsinday; // int seconds since midnight

// first some simple conversions
secs2days s::int | secs2days s::bigint | secs2days s::double = (s / secsinday);
days2secs d::int | days2secs d::bigint | deys2secs d::double = secsinday * d;
days2hours d::int| days2hours d::bigint| days2hours d::double= 24*d;
hours2days h::int = h / 24;

// conversions from/to days:hours:minutes:seconds format
// seconds can be int or bigint or double. d,h,m are ints
dhms2secs (d::int:h::int:m::int:s::int) |
dhms2secs (d::int:h::int:m::int:s::bigint) |
dhms2secs (d::int:h::int:m::int:s::double) = 60*(60*(24*d+h)+m)+s;
   
secs2dhms secs::int | secs2dhms secs::bigint | secs2dhms secs::double =
   d:(h mod 24):(m mod 60):(secs-60*m)
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
        d::int = h div 24 
   end;
   
// an arbitrary binary operator applied to two (days:hours:minutes:seconds) 
opdhms op (d1::int:h1::int:m1::int:s1)(d2::int:h2::int:m2::int:s2) =
   secs2dhms (op (dhms2secs (d1:h1:m1:s1)) (dhms2secs (d2:h2:m2:s2)));
      
// conversions from/to hours:minutes:seconds format for displaying time of day.
// hours may be more than 24 but use d:h:m:s for longer periods of time
hms2secs (h::int:m::int:s::int) |
hms2secs (h::int:m::int:s::bigint) |
hms2secs (h::int:m::int:s::double) = 60*(60*h+m)+s;
   
secs2hms secs::int | secs2hms secs::bigint | secs2hms secs::double = 
   h:(m mod 60):(secs-60*m)
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
   end;
   
// New Time Format! hours:3mins:10secs:secs = hours:tres:dicis:secs = h:t:d:s
// the normal seconds are now just a single digit 0-9
// dicis:secs are easy to read: 6:0 means 60 seconds, 12:5 125 seconds etc.
// tres - multiply by three to get traditional babylonian minutes
// hours as usual (24 hour clock)
htds2secs (h::int:t::int:d::int:s::int) = 10*(18*(20*h+t)+d)+s;
   
secs2htds secs::int | secs2htds secs::bigint | secs2htds secs::double =
   h:(t mod 20):(d mod 18):(secs-10*d)
   when 
        d::int = int (secs / 10);
        t::int = d div 18; 
        h::int = t div 20 
   end;

// not used yet but could be, as in: addmayan posixepoch (days2mayan posixdays)
addmayan (baktun1::int:katun1::int:tun1::int:vinal1::int:kin1::int)
   	   (baktun2::int:katun2::int:tun2::int:vinal2::int:kin2::int) =
   baktun:(katun mod 20):(tun mod 20):(vinal mod 18):(kin mod 20) 
   when 
   kin = kin1+kin2; vinal = vinal1+vinal2+(kin div 20); 
   tun = tun1+tun2+(vinal div 18); katun = katun1+katun2+(tun div 20);
   baktun = baktun1+baktun2+(katun div 20) 
   end;
   
days2mayan d::int = baktun:(katun mod 20):(tun mod 20):(vinal mod 18):(d mod 20)
   when 
   vinal =d div 20; tun =vinal div 18; katun =tun div 20; baktun =katun div 20
   end;

mayan2days (baktun::int:katun::int:tun::int:vinal::int:kin::int) = 
   20*(18*(20*(20*baktun+katun)+tun)+vinal)+kin;
   
// moon calculations
moonphase psecs::int=((psecs-(dhms2secs newmoondhms))mod lunarmonth)/lunarmonth;
// full moon percentage at psecs posix seconds
fullmoon psecs::int = if mf > 0.5 then 200.0*(1.0-mf) else 200.0*mf 
   when mf = moonphase psecs end;

// for now, let's just do some simple calculations to print
def epochday   = mayan2days posixepoch; // (mayan) day of the posix epoch
def cycledays  = mayan2days endofcycle; // total days in 13 Baktuns
daytoday = epochday + (secs2days posixsecsnow);  // mayan whole day count
mayantoday = days2mayan (int daytoday); // as above but in the long count format
daysleft = cycledays-epochday-(secs2days (double posixsecsnow)); // double
mayanleft = days2mayan ((int daysleft));
timeleft = secs2htds (secsinday - secsnow);
percentcomplete = 100.0*(epochday+posixsecsnow/secsinday)/cycledays;

usage = puts "Usage:  pure -x date.pure [anyarg]" $
        puts "\tanyarg for help";

case argc of 
  1 = 
   printf "%s \tUTC Time in h:m:s\n"  (str (secs2hms secsnow)) $ 
   printf "%s \tUTC Time in h:t:d:s\n"  (str (secs2htds (secsnow-1)))$ 
   printf "%7.4f %% \tFullness of the Moon\n" (fullmoon posixsecsnow) $
   printf "%d \tMayan day number\n" (int daytoday) $
   printf "%s \tMayan long count notation for this day\n" (str mayantoday) $
   printf "%s \tLong countdown of days to the end of this cycle\n" 
         (str mayanleft) $
   printf "%s \tTime (h:t:d:s) countdown of today\n" (str timeleft) $
   printf "%11.8f %%\tCompletion of the Mayan cycle of over 5125 years\n" 
         percentcomplete  $
   puts "****************************************************************";
  2 = 
   puts "Mayan long count digits (and their range of values):" $
   puts "Baktun(0-12) : Katun(0-19) : Tun(0-19) : Vinal(0-17) : Kin(0-19)" $
   puts "Baktun=144000days Katun=7200days Tun=360days Vinal=20days Kin=day" $
   puts "\nNew clock digits (and their range of values):" $
   puts "Hour(0-23) : Tre(0-19) : Dici(0-17) : Sec(0-9)" $
   puts "Hour=3600secs Tre=180secs Dici=10secs Sec=second\n" $
   puts "Complete time count: Baktun:Katun:Tun:Vinal:Kin,Hour:Tre:Dici:Sec\n" $
   usage;
  n = usage
end;
