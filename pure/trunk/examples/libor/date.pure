/* New Calendar and Clock 
   Copyright (c) 2008 by Libor Spacek
   
   Acknowledgement: thanks to Dr Albert Graef for his "Q" code for the 
   Gregorian date calculation 

   Usage: pure -x date.pure [-h]

   Discrepancies with your local clock may occur when C library's time(); 
   returns Posix time based on UTC (Universal Temps Coordinat) or TAI
   (Temps Atomique International) rather than local daylight saving time */

using system;      // this is needed just to get C printf
extern long time(long*) = c_time; // makes available the C function time();

puts "****************************************************************";
puts "*    New Calendar/Clock, Copyright (c) 2008 by Libor Spacek    *";
puts "****************************************************************";
// def posixepoch = (12:17:16:7:5); // Mayan long count date of the posix epoch
def mdayposix  = 1856305;        // Mayan day for the posix epoch Jan 1 1970
def jdayposix  = 2440588;        // Julian day for the posix epoch
// def endofcycle = (13:0:0:0:0);   // The end of the cycle
def cycledays  = 1872000;        // Total days in 13 Baktuns
def secsinday  = 86400;          // number of seconds in a day
def trueyear   = 31556941;// (in seconds) divisible by 13 = current true year
def myyear     = 31556943;// div by 2277, secsinday compatible, 365.2424 days
def gregyear   = 31556952;// div by 40824, mean gregorian year, 365.2425 days
def lunarmonth = 2551443;  // lunar (synodic) month to the nearest second
def newmoondhms= (14063:2:19:0); // 3rd July 08 new moon in posix dhms
   
// current values in posix time supplied by C time();
posixsecsnow = c_time (pointer 0); // each call refreshes to the current second
secsnow = posixsecsnow mod secsinday; // int seconds since midnight
   
// either mayan or julian day (and time) as a day number (::double)
mjday epoch::int secs::int |mjday epoch::int secs::bigint= epoch+secs/secsinday;

// first some simple conversions
jday2mday day::int | jday2mday day::double =  day - jdayposix + mdayposix;
mday2jday day::int | mday2jday day::double =  day - mdayposix + jdayposix;  
   
secs2days s::int | secs2days s::bigint | secs2days s::double = (s / secsinday);
days2secs d::int | days2secs d::bigint | deys2secs d::double = secsinday * d;
days2hours d::int| days2hours d::bigint| days2hours d::double= 24*d;
hours2days h::int = h / 24;

// conversions from/to days:hours:minutes:seconds format
// seconds can be int or double. d,h,m are ints
dhms2secs (d::int:h::int:m::int:s::int) |
dhms2secs (d::int:h::int:m::int:s::double) = 60*(60*(24*d+h)+m)+s;
   
secs2dhms secs::int | secs2dhms secs::bigint  = 
   d:(h mod 24):(m mod 60):(int (secs-60*m))
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
        d::int = h div 24 
   end;      
   
secs2dhms secs::double =  d:(h mod 24):(m mod 60):(secs-60*m)
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
        d::int = h div 24 
   end;
   
// an arbitrary binary operator applied to two (days:hours:minutes:seconds) 
opdhms op (d1::int:h1::int:m1::int:s1)(d2::int:h2::int:m2::int:s2) =
   secs2dhms (op (dhms2secs (d1:h1:m1:s1)) (dhms2secs (d2:h2:m2:s2)));
      
// conversions from/to hours:minutes:seconds format for displaying time of day.
// hours may be more than 24 but use d:h:m:s for longer periods of time
hms2secs (h::int:m::int:s::int) |
hms2secs (h::int:m::int:s::double) = 60*(60*h+m)+s;
   
secs2hms secs::int | secs2hms secs::bigint = h:(m mod 60):(int (secs-60*m))
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
   end;  
secs2hms secs::double =  h:(m mod 60):(secs-60*m)
   when 
        m::int = int (secs / 60);
        h::int = m div 60; 
   end;
   
// New Time Format! hours:3mins:10secs:secs = hours:tres:dicis:secs = h:t:d:s
// the normal seconds are now just a single digit 0-9
// dicis:secs are easy to read: 6:0 means 60 seconds, 12:5 125 seconds etc.
// tres - multiply by three to get traditional babylonian minutes
// hours as usual (24 hour clock)
htds2secs (h::int:t::int:d::int:s::int)| 
htds2secs (h::int:t::int:d::int:s::double) = 10*(18*(20*h+t)+d)+s;
   
secs2htds secs::int | secs2htds secs::bigint  =
   h:(t mod 20):(d mod 18):(int (secs-10*d))
   when 
        d::int = int (secs / 10);
        t::int = d div 18; 
        h::int = t div 20 
   end;

secs2htds secs::double = h:(t mod 20):(d mod 18):(secs-10*d)
   when 
        d::int = int (secs / 10);
        t::int = d div 18; 
        h::int = t div 20 
   end;

// not used yet but could be, as in: addmayan posixepoch (days2mayan posixdays)
addmayan (baktun1::int:katun1::int:tun1::int:vinal1::int:kin1::int)
   	   (baktun2::int:katun2::int:tun2::int:vinal2::int:kin2::int) =
   baktun:(katun mod 20):(tun mod 20):(vinal mod 18):(kin mod 20) 
   when 
   kin = kin1+kin2; vinal = vinal1+vinal2+(kin div 20); 
   tun = tun1+tun2+(vinal div 18); katun = katun1+katun2+(tun div 20);
   baktun = baktun1+baktun2+(katun div 20) 
   end;
   
days2mayan d::int = baktun:(katun mod 20):(tun mod 20):(vinal mod 18):(d mod 20)
   when 
   vinal =d div 20; tun =vinal div 18; katun =tun div 20; baktun =katun div 20
   end;

mayan2days (baktun::int:katun::int:tun::int:vinal::int:kin::int) = 
   20*(18*(20*(20*baktun+katun)+tun)+vinal)+kin;
   
/* Gregorian date for Julian day number. Please note that these dates are
   historically correct only after the introduction of the Gregorian calendar
   in 1582 (even much later in some countries). */

date N::int  = (E-(153*M+2) div 5+1, M+3-12*(M div 10), 100*B+D-4800+M div 10)
          when A = N+32044; B = (4*A+3) div 146097;
            C = A-146097*B div 4; D = (4*C+3) div 1461;
            E = C-1461*D div 4; M = (5*E+2) div 153 end;
   
   
// moon calculations
moonphase psecs::int | moonphase psecs::bigint =
   ((psecs-(dhms2secs newmoondhms))mod lunarmonth)/lunarmonth;
// full moon percentage at psecs posix seconds
fullmoon psecs::int | fullmoon psecs::bigint = 
   if mf > 0.5 then 200.0*(1.0-mf) else 200.0*mf when mf = moonphase psecs end;
   
// for now, let's just do some simple calculations to print
daytoday = mjday mdayposix posixsecsnow; // mayan day (double)
mayantoday = days2mayan (int daytoday); // as above but in the long count format
daysleft = cycledays - daytoday;
mayanleft = days2mayan ((int daysleft));
timeleft = secs2htds (secsinday - secsnow);
percentcomplete = 100.0*daytoday/cycledays;

usage = puts "Usage:  pure -x date.pure [anyarg]" $
        puts "\tanyarg for help\n";

case argc of 
  1 =
   printf "%s \tToday's Gregorian Date\n"(str(date(mday2jday(int daytoday))))$
   printf "%s  \tUTC Time in h:m:s\n"  (str (secs2hms secsnow)) $ 
   printf "%s \tUTC Time in h:t:d:s\n"  (str (secs2htds secsnow))$ 
   printf "%7.4f %% \tFullness of the Moon\n" (fullmoon posixsecsnow) $
   printf "%d \tMayan day number\n" (int daytoday) $
   printf "%s \tMayan long count notation for this day\n" (str mayantoday) $
   printf "%s \tLong countdown of days to the end of this cycle\n" 
         (str mayanleft) $
   printf "%s \tTime (h:t:d:s) countdown of today\n" (str timeleft) $
   printf "%11.8f %%\tCompletion of the Mayan cycle of over 5125 years\n" 
         percentcomplete  $
   puts "****************************************************************";
  2 = 
   puts "Mayan long count digits and their ranges of values:" $
   puts "Baktun(0-12) : Katun(0-19) : Tun(0-19) : Vinal(0-17) : Kin(0-19)" $
   puts "Baktun=144000days Katun=7200days Tun=360days Vinal=20days Kin=day" $
   puts "\nNew clock digits and their ranges of values:" $
   puts "hour(0-23) : tre(0-19) : dici(0-17) : second(0-9)" $
   puts "hour=3600s : tre=180s  : dici=10s   : s=second\n" $
   puts "Full time spec: Baktun:Katun:Tun:Vinal:Kin hour:tre:dici:second\n" $
   usage;
  n = usage
end;
