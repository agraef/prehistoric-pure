throw x/*0:1*/ = pure_throw x/*0:1*/;
assert p/*0:01*/ e/*0:1*/ = if p/*0:01*/ then 1 else throw e/*0:1*/;
x/*0:01*/===y/*0:1*/ = same x/*0:01*/ y/*0:1*/;
x/*0:01*/!==y/*0:1*/ = not same x/*0:01*/ y/*0:1*/;
intp x/*0:1*/ = case x/*0:1*/ of _/*0:*/::int = 1; _/*0:*/ = 0 {
  rule #0: _::int = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::int state 2
  state 1: #1
  state 2: #0 #1
} end;
bigintp x/*0:1*/ = case x/*0:1*/ of _/*0:*/::bigint = 1; _/*0:*/ = 0 {
  rule #0: _::bigint = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::bigint state 2
  state 1: #1
  state 2: #0 #1
} end;
doublep x/*0:1*/ = case x/*0:1*/ of _/*0:*/::double = 1; _/*0:*/ = 0 {
  rule #0: _::double = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::double state 2
  state 1: #1
  state 2: #0 #1
} end;
stringp x/*0:1*/ = case x/*0:1*/ of _/*0:*/::string = 1; _/*0:*/ = 0 {
  rule #0: _::string = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var>::string state 2
  state 1: #1
  state 2: #0 #1
} end;
pointerp x/*0:1*/ = case x/*0:1*/ of _/*0:*/ = 1; _/*0:*/ = 0 {
  rule #0: _ = 1
  rule #1: _ = 0
  state 0: #0 #1
	<var> state 1
	<var> state 2
  state 1: #1
  state 2: #0 #1
} end;
listp [] = 1;
listp (x/*0:101*/:xs/*0:11*/) = listp xs/*0:11*/;
listp _/*0:1*/ = 0;
listnp [] = 1;
listnp (x/*0:101*/:xs/*0:11*/) = 1;
listnp _/*0:1*/ = 0;
tuplep () = 1;
tuplep (x/*0:101*/,xs/*0:11*/) = 1;
tuplep _/*0:1*/ = 0;
int x/*0:1*/::int = x/*0:1*/;
int x/*0:1*/::bigint = pure_intval x/*0:1*/;
int x/*0:1*/::double = pure_intval x/*0:1*/;
int x/*0:1*/ = pure_intval x/*0:1*/;
bigint x/*0:1*/::int = pure_bigintval x/*0:1*/;
bigint x/*0:1*/::bigint = x/*0:1*/;
bigint x/*0:1*/::double = pure_bigintval x/*0:1*/;
bigint x/*0:1*/ = pure_bigintval x/*0:1*/;
double x/*0:1*/::int = pure_dblval x/*0:1*/;
double x/*0:1*/::bigint = pure_dblval x/*0:1*/;
double x/*0:1*/::double = x/*0:1*/;
pointer x/*0:1*/::int = pure_pointerval x/*0:1*/;
pointer x/*0:1*/::bigint = pure_pointerval x/*0:1*/;
pointer x/*0:1*/::double = pure_pointerval x/*0:1*/;
pointer x/*0:1*/::string = pure_pointerval x/*0:1*/;
pointer x/*0:1*/ = x/*0:1*/;
-x/*0:1*/::int = -x/*0:1*/;
~x/*0:1*/::int = ~x/*0:1*/;
not x/*0:1*/::int = not x/*0:1*/;
x/*0:01*/::int<<y/*0:1*/::int = x/*0:01*/<<y/*0:1*/;
x/*0:01*/::int>>y/*0:1*/::int = x/*0:01*/>>y/*0:1*/;
x/*0:01*/::int+y/*0:1*/::int = x/*0:01*/+y/*0:1*/;
x/*0:01*/::int-y/*0:1*/::int = x/*0:01*/-y/*0:1*/;
x/*0:01*/::int*y/*0:1*/::int = x/*0:01*/*y/*0:1*/;
x/*0:01*/::int/y/*0:1*/::int = x/*0:01*//y/*0:1*/;
x/*0:01*/::int div y/*0:1*/::int = x/*0:01*/ div y/*0:1*/;
x/*0:01*/::int mod y/*0:1*/::int = x/*0:01*/ mod y/*0:1*/;
x/*0:01*/::int or y/*0:1*/::int = x/*0:01*/ or y/*0:1*/;
x/*0:01*/::int and y/*0:1*/::int = x/*0:01*/ and y/*0:1*/;
x/*0:01*/::int<y/*0:1*/::int = x/*0:01*/<y/*0:1*/;
x/*0:01*/::int>y/*0:1*/::int = x/*0:01*/>y/*0:1*/;
x/*0:01*/::int<=y/*0:1*/::int = x/*0:01*/<=y/*0:1*/;
x/*0:01*/::int>=y/*0:1*/::int = x/*0:01*/>=y/*0:1*/;
x/*0:01*/::int==y/*0:1*/::int = x/*0:01*/==y/*0:1*/;
x/*0:01*/::int!=y/*0:1*/::int = x/*0:01*/!=y/*0:1*/;
-x/*0:1*/::double = -x/*0:1*/;
x/*0:01*/::double+y/*0:1*/::double = x/*0:01*/+y/*0:1*/;
x/*0:01*/::double-y/*0:1*/::double = x/*0:01*/-y/*0:1*/;
x/*0:01*/::double*y/*0:1*/::double = x/*0:01*/*y/*0:1*/;
x/*0:01*/::double/y/*0:1*/::double = x/*0:01*//y/*0:1*/;
x/*0:01*/::double<y/*0:1*/::double = x/*0:01*/<y/*0:1*/;
x/*0:01*/::double>y/*0:1*/::double = x/*0:01*/>y/*0:1*/;
x/*0:01*/::double<=y/*0:1*/::double = x/*0:01*/<=y/*0:1*/;
x/*0:01*/::double>=y/*0:1*/::double = x/*0:01*/>=y/*0:1*/;
x/*0:01*/::double==y/*0:1*/::double = x/*0:01*/==y/*0:1*/;
x/*0:01*/::double!=y/*0:1*/::double = x/*0:01*/!=y/*0:1*/;
x/*0:01*/::int+y/*0:1*/::double = x/*0:01*/+y/*0:1*/;
x/*0:01*/::int-y/*0:1*/::double = x/*0:01*/-y/*0:1*/;
x/*0:01*/::int*y/*0:1*/::double = x/*0:01*/*y/*0:1*/;
x/*0:01*/::int/y/*0:1*/::double = x/*0:01*//y/*0:1*/;
x/*0:01*/::int<y/*0:1*/::double = x/*0:01*/<y/*0:1*/;
x/*0:01*/::int>y/*0:1*/::double = x/*0:01*/>y/*0:1*/;
x/*0:01*/::int<=y/*0:1*/::double = x/*0:01*/<=y/*0:1*/;
x/*0:01*/::int>=y/*0:1*/::double = x/*0:01*/>=y/*0:1*/;
x/*0:01*/::int==y/*0:1*/::double = x/*0:01*/==y/*0:1*/;
x/*0:01*/::int!=y/*0:1*/::double = x/*0:01*/!=y/*0:1*/;
x/*0:01*/::double+y/*0:1*/::int = x/*0:01*/+y/*0:1*/;
x/*0:01*/::double-y/*0:1*/::int = x/*0:01*/-y/*0:1*/;
x/*0:01*/::double*y/*0:1*/::int = x/*0:01*/*y/*0:1*/;
x/*0:01*/::double/y/*0:1*/::int = x/*0:01*//y/*0:1*/;
x/*0:01*/::double<y/*0:1*/::int = x/*0:01*/<y/*0:1*/;
x/*0:01*/::double>y/*0:1*/::int = x/*0:01*/>y/*0:1*/;
x/*0:01*/::double<=y/*0:1*/::int = x/*0:01*/<=y/*0:1*/;
x/*0:01*/::double>=y/*0:1*/::int = x/*0:01*/>=y/*0:1*/;
x/*0:01*/::double==y/*0:1*/::int = x/*0:01*/==y/*0:1*/;
x/*0:01*/::double!=y/*0:1*/::int = x/*0:01*/!=y/*0:1*/;
x/*0:01*/::int&&y/*0:1*/::int = x/*0:01*/&&y/*0:1*/;
x/*0:01*/::int||y/*0:1*/::int = x/*0:01*/||y/*0:1*/;
-x/*0:1*/::bigint = bigint_neg x/*0:1*/;
~x/*0:1*/::bigint = bigint_not x/*0:1*/;
not x/*0:1*/::bigint = not int x/*0:1*/;
x/*0:01*/::bigint<<y/*0:1*/::int = bigint_shl x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
x/*0:01*/::bigint<<y/*0:1*/::int = bigint_shr x/*0:01*/ (-y/*0:1*/);
x/*0:01*/::bigint>>y/*0:1*/::int = bigint_shr x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
x/*0:01*/::bigint>>y/*0:1*/::int = bigint_shl x/*0:01*/ (-y/*0:1*/);
x/*0:01*/::bigint+y/*0:1*/::bigint = bigint_add x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint-y/*0:1*/::bigint = bigint_sub x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint*y/*0:1*/::bigint = bigint_mul x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint/y/*0:1*/::bigint = double x/*0:01*//double y/*0:1*/;
x/*0:01*/::bigint div y/*0:1*/::bigint = bigint_div x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint mod y/*0:1*/::bigint = bigint_mod x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint or y/*0:1*/::bigint = bigint_or x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint and y/*0:1*/::bigint = bigint_and x/*0:01*/ y/*0:1*/;
x/*0:01*/::bigint<y/*0:1*/::bigint = bigint_cmp x/*0:01*/ y/*0:1*/<0;
x/*0:01*/::bigint>y/*0:1*/::bigint = bigint_cmp x/*0:01*/ y/*0:1*/>0;
x/*0:01*/::bigint<=y/*0:1*/::bigint = bigint_cmp x/*0:01*/ y/*0:1*/<=0;
x/*0:01*/::bigint>=y/*0:1*/::bigint = bigint_cmp x/*0:01*/ y/*0:1*/>=0;
x/*0:01*/::bigint==y/*0:1*/::bigint = bigint_cmp x/*0:01*/ y/*0:1*/==0;
x/*0:01*/::bigint!=y/*0:1*/::bigint = bigint_cmp x/*0:01*/ y/*0:1*/!=0;
x/*0:01*/::int+y/*0:1*/::bigint = bigint x/*0:01*/+y/*0:1*/;
x/*0:01*/::int-y/*0:1*/::bigint = bigint x/*0:01*/-y/*0:1*/;
x/*0:01*/::int*y/*0:1*/::bigint = bigint x/*0:01*/*y/*0:1*/;
x/*0:01*/::int/y/*0:1*/::bigint = double x/*0:01*//y/*0:1*/;
x/*0:01*/::int div y/*0:1*/::bigint = bigint x/*0:01*/ div y/*0:1*/;
x/*0:01*/::int mod y/*0:1*/::bigint = bigint x/*0:01*/ mod y/*0:1*/;
x/*0:01*/::int or y/*0:1*/::bigint = bigint x/*0:01*/ or y/*0:1*/;
x/*0:01*/::int and y/*0:1*/::bigint = bigint x/*0:01*/ and y/*0:1*/;
x/*0:01*/::int<y/*0:1*/::bigint = bigint x/*0:01*/<y/*0:1*/;
x/*0:01*/::int>y/*0:1*/::bigint = bigint x/*0:01*/>y/*0:1*/;
x/*0:01*/::int<=y/*0:1*/::bigint = bigint x/*0:01*/<=y/*0:1*/;
x/*0:01*/::int>=y/*0:1*/::bigint = bigint x/*0:01*/>=y/*0:1*/;
x/*0:01*/::int==y/*0:1*/::bigint = bigint x/*0:01*/==y/*0:1*/;
x/*0:01*/::int!=y/*0:1*/::bigint = bigint x/*0:01*/!=y/*0:1*/;
x/*0:01*/::bigint+y/*0:1*/::int = x/*0:01*/+bigint y/*0:1*/;
x/*0:01*/::bigint-y/*0:1*/::int = x/*0:01*/-bigint y/*0:1*/;
x/*0:01*/::bigint*y/*0:1*/::int = x/*0:01*/*bigint y/*0:1*/;
x/*0:01*/::bigint/y/*0:1*/::int = x/*0:01*//double y/*0:1*/;
x/*0:01*/::bigint div y/*0:1*/::int = x/*0:01*/ div bigint y/*0:1*/;
x/*0:01*/::bigint mod y/*0:1*/::int = x/*0:01*/ mod bigint y/*0:1*/;
x/*0:01*/::bigint or y/*0:1*/::int = x/*0:01*/ or bigint y/*0:1*/;
x/*0:01*/::bigint and y/*0:1*/::int = x/*0:01*/ and bigint y/*0:1*/;
x/*0:01*/::bigint<y/*0:1*/::int = x/*0:01*/<bigint y/*0:1*/;
x/*0:01*/::bigint>y/*0:1*/::int = x/*0:01*/>bigint y/*0:1*/;
x/*0:01*/::bigint<=y/*0:1*/::int = x/*0:01*/<=bigint y/*0:1*/;
x/*0:01*/::bigint>=y/*0:1*/::int = x/*0:01*/>=bigint y/*0:1*/;
x/*0:01*/::bigint==y/*0:1*/::int = x/*0:01*/==bigint y/*0:1*/;
x/*0:01*/::bigint!=y/*0:1*/::int = x/*0:01*/!=bigint y/*0:1*/;
x/*0:01*/::bigint+y/*0:1*/::double = double x/*0:01*/+y/*0:1*/;
x/*0:01*/::bigint-y/*0:1*/::double = double x/*0:01*/-y/*0:1*/;
x/*0:01*/::bigint*y/*0:1*/::double = double x/*0:01*/*y/*0:1*/;
x/*0:01*/::bigint/y/*0:1*/::double = double x/*0:01*//y/*0:1*/;
x/*0:01*/::bigint<y/*0:1*/::double = double x/*0:01*/<y/*0:1*/;
x/*0:01*/::bigint>y/*0:1*/::double = double x/*0:01*/>y/*0:1*/;
x/*0:01*/::bigint<=y/*0:1*/::double = double x/*0:01*/<=y/*0:1*/;
x/*0:01*/::bigint>=y/*0:1*/::double = double x/*0:01*/>=y/*0:1*/;
x/*0:01*/::bigint==y/*0:1*/::double = double x/*0:01*/==y/*0:1*/;
x/*0:01*/::bigint!=y/*0:1*/::double = double x/*0:01*/!=y/*0:1*/;
x/*0:01*/::double+y/*0:1*/::bigint = x/*0:01*/+double y/*0:1*/;
x/*0:01*/::double-y/*0:1*/::bigint = x/*0:01*/-double y/*0:1*/;
x/*0:01*/::double*y/*0:1*/::bigint = x/*0:01*/*double y/*0:1*/;
x/*0:01*/::double/y/*0:1*/::bigint = x/*0:01*//double y/*0:1*/;
x/*0:01*/::double<y/*0:1*/::bigint = x/*0:01*/<double y/*0:1*/;
x/*0:01*/::double>y/*0:1*/::bigint = x/*0:01*/>double y/*0:1*/;
x/*0:01*/::double<=y/*0:1*/::bigint = x/*0:01*/<=double y/*0:1*/;
x/*0:01*/::double>=y/*0:1*/::bigint = x/*0:01*/>=double y/*0:1*/;
x/*0:01*/::double==y/*0:1*/::bigint = x/*0:01*/==double y/*0:1*/;
x/*0:01*/::double!=y/*0:1*/::bigint = x/*0:01*/!=double y/*0:1*/;
sqrt x/*0:1*/::int = c_sqrt (double x/*0:1*/) if x/*0:1*/>=0;
sqrt x/*0:1*/::bigint = c_sqrt (double x/*0:1*/) if x/*0:1*/>=0;
sqrt x/*0:1*/::double = c_sqrt x/*0:1*/ if x/*0:1*/>=0;
pow x/*0:01*/::int y/*0:1*/::int = bigint_pow (bigint x/*0:01*/) y/*0:1*/ if y/*0:1*/>=0;
pow x/*0:01*/::bigint y/*0:1*/::bigint = bigint_pow x/*0:01*/ (int y/*0:1*/) if int y/*0:1*/>=0;
pow x/*0:01*/::double y/*0:1*/::double = c_pow x/*0:01*/ y/*0:1*/ if x/*0:01*/>=0||int y/*0:1*/==y/*0:1*/;
pow x/*0:01*/::int y/*0:1*/::bigint = bigint_pow (bigint x/*0:01*/) (int y/*0:1*/) if y/*0:1*/>=0;
pow x/*0:01*/::bigint y/*0:1*/::int = bigint_pow x/*0:01*/ y/*0:1*/ if y/*0:1*/>=0;
pow x/*0:01*/::double y/*0:1*/::int = c_pow x/*0:01*/ (double y/*0:1*/);
pow x/*0:01*/::double y/*0:1*/::bigint = c_pow x/*0:01*/ (double y/*0:1*/);
pow x/*0:01*/::int y/*0:1*/::double = c_pow (double x/*0:01*/) y/*0:1*/ if x/*0:01*/>=0||int y/*0:1*/==y/*0:1*/;
pow x/*0:01*/::bigint y/*0:1*/::double = c_pow (double x/*0:01*/) y/*0:1*/ if x/*0:01*/>=0||int y/*0:1*/==y/*0:1*/;
x/*0:01*/::double^y/*0:1*/::double = c_pow x/*0:01*/ y/*0:1*/ if x/*0:01*/>=0||int y/*0:1*/==y/*0:1*/;
x/*0:01*/::int^y/*0:1*/::int = c_pow (double x/*0:01*/) (double y/*0:1*/);
x/*0:01*/::bigint^y/*0:1*/::bigint = c_pow (double x/*0:01*/) (double y/*0:1*/);
x/*0:01*/::int^y/*0:1*/::bigint = c_pow (double x/*0:01*/) (double y/*0:1*/);
x/*0:01*/::bigint^y/*0:1*/::int = c_pow (double x/*0:01*/) (double y/*0:1*/);
x/*0:01*/::double^y/*0:1*/::int = c_pow x/*0:01*/ (double y/*0:1*/);
x/*0:01*/::double^y/*0:1*/::bigint = c_pow x/*0:01*/ (double y/*0:1*/);
x/*0:01*/::int^y/*0:1*/::double = c_pow (double x/*0:01*/) y/*0:1*/ if x/*0:01*/>=0||int y/*0:1*/==y/*0:1*/;
x/*0:01*/::bigint^y/*0:1*/::double = c_pow (double x/*0:01*/) y/*0:1*/ if x/*0:01*/>=0||int y/*0:1*/==y/*0:1*/;
null x/*0:1*/ = bigint x/*0:1*/==0;
x/*0:01*/-y/*0:1*/ = bigint x/*0:01*/-bigint y/*0:1*/;
x/*0:01*/+y/*0:1*/::int = pointer (bigint x/*0:01*/+y/*0:1*/);
x/*0:01*/+y/*0:1*/::bigint = pointer (bigint x/*0:01*/+y/*0:1*/);
x/*0:01*/<y/*0:1*/ = bigint x/*0:01*/<bigint y/*0:1*/;
x/*0:01*/>y/*0:1*/ = bigint x/*0:01*/>bigint y/*0:1*/;
x/*0:01*/<=y/*0:1*/ = bigint x/*0:01*/<=bigint y/*0:1*/;
x/*0:01*/>=y/*0:1*/ = bigint x/*0:01*/>=bigint y/*0:1*/;
x/*0:01*/==y/*0:1*/ = bigint x/*0:01*/==bigint y/*0:1*/;
x/*0:01*/!=y/*0:1*/ = bigint x/*0:01*/!=bigint y/*0:1*/;
get_byte x/*0:1*/ = pointer_get_byte x/*0:1*/;
get_int x/*0:1*/ = pointer_get_int x/*0:1*/;
get_double x/*0:1*/ = pointer_get_double x/*0:1*/;
get_string x/*0:1*/ = pointer_get_string x/*0:1*/;
get_pointer x/*0:1*/ = pointer_get_pointer x/*0:1*/;
put_byte x/*0:01*/ y/*0:1*/::int = pointer_put_byte x/*0:01*/ y/*0:1*/;
put_int x/*0:01*/ y/*0:1*/::int = pointer_put_int x/*0:01*/ y/*0:1*/;
put_double x/*0:01*/ y/*0:1*/::double = pointer_put_double x/*0:01*/ y/*0:1*/;
put_string x/*0:01*/ y/*0:1*/::string = pointer_put_string x/*0:01*/ y/*0:1*/;
put_pointer x/*0:01*/ y/*0:1*/::string = pointer_put_pointer x/*0:01*/ y/*0:1*/;
put_pointer x/*0:01*/ y/*0:1*/ = pointer_put_pointer x/*0:01*/ y/*0:1*/;
chr n/*0:1*/::int = string_chr n/*0:1*/ if n/*0:1*/>0;
ord s/*0:1*/::string = string_ord s/*0:1*/ if #s/*0:1*/==1;
string s/*0:1*/ = pure_string s/*0:1*/;
cstring s/*0:1*/ = pure_cstring s/*0:1*/;
string_dup s/*0:1*/ = pure_string_dup s/*0:1*/;
cstring_dup s/*0:1*/ = pure_cstring_dup s/*0:1*/;
byte_string s/*0:1*/::string = pure_byte_string s/*0:1*/;
byte_cstring s/*0:1*/::string = pure_byte_cstring s/*0:1*/;
c/*0:01*/::string+n/*0:1*/::int = chr (ord c/*0:01*/+n/*0:1*/) if #c/*0:01*/==1;
c/*0:01*/::string-n/*0:1*/::int = chr (ord c/*0:01*/-n/*0:1*/) if #c/*0:01*/==1&&ord c/*0:01*/>=n/*0:1*/;
c/*0:01*/::string-d/*0:1*/::string = ord c/*0:01*/-ord d/*0:1*/ if #c/*0:01*/==1&&#d/*0:1*/==1;
null s/*0:1*/::string = string_null s/*0:1*/;
#s/*0:1*/::string = string_size s/*0:1*/;
s/*0:01*/::string!n/*0:1*/::int = string_char_at s/*0:01*/ n/*0:1*/ if n/*0:1*/>=0&&n/*0:1*/<#s/*0:01*/;
s/*0:01*/::string+t/*0:1*/::string = string_concat s/*0:01*/ t/*0:1*/;
chars s/*0:1*/::string = string_chars s/*0:1*/;
x/*0:01*/::string<y/*0:1*/::string = strcmp x/*0:01*/ y/*0:1*/<0;
x/*0:01*/::string>y/*0:1*/::string = strcmp x/*0:01*/ y/*0:1*/>0;
x/*0:01*/::string<=y/*0:1*/::string = strcmp x/*0:01*/ y/*0:1*/<=0;
x/*0:01*/::string>=y/*0:1*/::string = strcmp x/*0:01*/ y/*0:1*/>=0;
x/*0:01*/::string==y/*0:1*/::string = strcmp x/*0:01*/ y/*0:1*/==0;
x/*0:01*/::string!=y/*0:1*/::string = strcmp x/*0:01*/ y/*0:1*/!=0;
substr s/*0:001*/::string pos/*0:01*/::int size/*0:1*/::int = string_substr s/*0:001*/ (max/*0*/ 0 pos/*0:01*/) (max/*0*/ 0 size/*0:1*/) with max x/*0:01*/ y/*0:1*/ = if x/*0:01*/>=y/*0:1*/ then x/*0:01*/ else y/*0:1*/ {
  rule #0: max x y = if x>=y then x else y
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end;
index s/*0:01*/::string u/*0:1*/::string = string_index s/*0:01*/ u/*0:1*/;
strcat xs/*0:1*/ = string_concat_list xs/*0:1*/ if listp xs/*0:1*/&&all stringp xs/*0:1*/;
join delim/*0:01*/::string [] = "";
join delim/*0:01*/::string (x/*0:101*/::string:xs/*0:11*/) = x/*0:101*/+strcat (catmap (\x/*0:*/ -> [delim/*1:01*/+x/*0:*/] {
  rule #0: x = [delim+x]
  state 0: #0
	<var> state 1
  state 1: #0
}) xs/*0:11*/) if listp xs/*0:11*/&&all stringp xs/*0:11*/;
split delim/*0:01*/::string s/*0:1*/::string = if null s/*1:1*/ then [] else split1/*0*/ delim/*1:01*/ s/*1:1*/ with split1 delim/*0:01*/ s/*0:1*/ = case index s/*0:1*/ delim/*0:01*/ of n/*0:*/ = take n/*0:*/ s/*1:1*/:split1/*2*/ delim/*1:01*/ (drop (n/*0:*/+m/*2:*/) s/*1:1*/) if n/*0:*/>=0; n/*0:*/ = [s/*1:1*/] {
  rule #0: n = take n s:split1 delim (drop (n+m) s) if n>=0
  rule #1: n = [s]
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
} end {
  rule #0: split1 delim s = case index s delim of n = take n s:split1 delim (drop (n+m) s) if n>=0; n = [s] end
  state 0: #0
	<var> state 1
  state 1: #0
	<var> state 2
  state 2: #0
} end when m/*0:*/ = #delim/*0:01*/ {
  rule #0: m = #delim
  state 0: #0
	<var> state 1
  state 1: #0
} end if not null delim/*0:01*/;
list s/*0:1*/::string = chars s/*0:1*/;
tuple s/*0:1*/::string = tuple (chars s/*0:1*/);
reverse s/*0:1*/::string = strcat (reverse (chars s/*0:1*/));
cat (s/*0:101*/::string:xs/*0:11*/) = cat (chars s/*0:101*/:xs/*0:11*/);
cycle n/*0:01*/::int "" = "";
cycle n/*0:01*/::int s/*0:1*/::string = "" if n/*0:01*/<=0;
cycle n/*0:01*/::int s/*0:1*/::string = accum/*0*/ [] n/*1:01*/ with accum ys/*0:01*/ n/*0:1*/ = strcat ys/*0:01*/+take n/*0:1*/ s/*2:1*/ if n/*0:1*/<=m/*1:*/; accum ys/*0:01*/ n/*0:1*/ = accum/*1*/ (s/*2:1*/:ys/*0:01*/) (n/*0:1*/-m/*1:*/) {
  rule #0: accum ys n = strcat ys+take n s if n<=m
  rule #1: accum ys n = accum (s:ys) (n-m)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
} end when m/*0:*/::int = #s/*0:1*/ {
  rule #0: m::int = #s
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
all p/*0:01*/ s/*0:1*/::string = all p/*0:01*/ (chars s/*0:1*/);
any p/*0:01*/ s/*0:1*/::string = any p/*0:01*/ (chars s/*0:1*/);
do f/*0:01*/ s/*0:1*/::string = do f/*0:01*/ (chars s/*0:1*/);
drop n/*0:01*/ s/*0:1*/::string = substr s/*0:1*/ n/*0:01*/ (#s/*0:1*/-n/*0:01*/);
dropwhile p/*0:01*/ s/*0:1*/::string = strcat (dropwhile p/*0:01*/ (chars s/*0:1*/));
filter p/*0:01*/ s/*0:1*/::string = strcat (filter p/*0:01*/ (chars s/*0:1*/));
foldl f/*0:001*/ a/*0:01*/ s/*0:1*/::string = foldl f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
foldl1 f/*0:01*/ s/*0:1*/::string = foldl1 f/*0:01*/ (chars s/*0:1*/);
foldr f/*0:001*/ a/*0:01*/ s/*0:1*/::string = foldr f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
foldr1 f/*0:01*/ s/*0:1*/::string = foldr1 f/*0:01*/ (chars s/*0:1*/);
head s/*0:1*/::string = s/*0:1*/!0 if not null s/*0:1*/;
init s/*0:1*/::string = substr s/*0:1*/ 0 (#s/*0:1*/-1) if not null s/*0:1*/;
last s/*0:1*/::string = s/*0:1*/!(#s/*0:1*/-1) if not null s/*0:1*/;
map f/*0:01*/ s/*0:1*/::string = map f/*0:01*/ (chars s/*0:1*/);
scanl f/*0:001*/ a/*0:01*/ s/*0:1*/::string = scanl f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
scanl1 f/*0:01*/ s/*0:1*/::string = scanl1 f/*0:01*/ (chars s/*0:1*/);
scanr f/*0:001*/ a/*0:01*/ s/*0:1*/::string = scanr f/*0:001*/ a/*0:01*/ (chars s/*0:1*/);
scanr1 f/*0:01*/ s/*0:1*/::string = scanr1 f/*0:01*/ (chars s/*0:1*/);
take n/*0:01*/ s/*0:1*/::string = substr s/*0:1*/ 0 n/*0:01*/;
takewhile p/*0:01*/ s/*0:1*/::string = strcat (takewhile p/*0:01*/ (chars s/*0:1*/));
tail s/*0:1*/::string = substr s/*0:1*/ 1 (#s/*0:1*/-1) if not null s/*0:1*/;
zip s/*0:01*/::string t/*0:1*/::string = zip (chars s/*0:01*/) (chars t/*0:1*/);
zip3 s/*0:001*/::string t/*0:01*/::string u/*0:1*/::string = zip3 (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
zipwith f/*0:001*/ s/*0:01*/::string t/*0:1*/::string = zipwith f/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
zipwith3 f/*0:0001*/ s/*0:001*/::string t/*0:01*/::string u/*0:1*/::string = zipwith3 f/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
dowith f/*0:001*/ s/*0:01*/::string t/*0:1*/::string = dowith f/*0:001*/ (chars s/*0:01*/) (chars t/*0:1*/);
dowith3 f/*0:0001*/ s/*0:001*/::string t/*0:01*/::string u/*0:1*/::string = dowith3 f/*0:0001*/ (chars s/*0:001*/) (chars t/*0:01*/) (chars u/*0:1*/);
f/*0:01*/$x/*0:1*/ = f/*0:01*/ x/*0:1*/;
(f/*0:001*/.g/*0:01*/) x/*0:1*/ = f/*0:001*/ (g/*0:01*/ x/*0:1*/);
void _/*0:1*/ = ();
id x/*0:1*/ = x/*0:1*/;
const x/*0:01*/ y/*0:1*/ = x/*0:01*/;
flip f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ y/*0:1*/ x/*0:01*/;
curry f/*0:001*/ x/*0:01*/ y/*0:1*/ = f/*0:001*/ (x/*0:01*/,y/*0:1*/);
curry3 f/*0:0001*/ x/*0:001*/ y/*0:01*/ z/*0:1*/ = f/*0:0001*/ (x/*0:001*/,y/*0:01*/,z/*0:1*/);
uncurry f/*0:01*/ (x/*0:101*/,y/*0:11*/) = f/*0:01*/ x/*0:101*/ y/*0:11*/;
uncurry3 f/*0:01*/ (x/*0:101*/,y/*0:1101*/,z/*0:111*/) = f/*0:01*/ x/*0:101*/ y/*0:1101*/ z/*0:111*/;
x/*0:01*/,() = x/*0:01*/;
(),y/*0:1*/ = y/*0:1*/;
(x/*0:0101*/,y/*0:011*/),z/*0:1*/ = x/*0:0101*/,y/*0:011*/,z/*0:1*/;
()==() = 1;
(x/*0:0101*/,xs/*0:011*/)==() = 0;
()==(x/*0:101*/,xs/*0:11*/) = 0;
(x/*0:0101*/,xs/*0:011*/)==(y/*0:101*/,ys/*0:11*/) = if x/*0:0101*/==y/*0:101*/ then xs/*0:011*/==ys/*0:11*/ else 0;
()!=() = 0;
(x/*0:0101*/,xs/*0:011*/)!=() = 1;
()!=(x/*0:101*/,xs/*0:11*/) = 1;
(x/*0:0101*/,xs/*0:011*/)!=(y/*0:101*/,ys/*0:11*/) = if x/*0:0101*/!=y/*0:101*/ then 1 else xs/*0:011*/!=ys/*0:11*/;
null () = 1;
null (x/*0:101*/,xs/*0:11*/) = 0;
#() = 0;
#(x/*0:101*/,xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/::int (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/::int x/*0:1*/ = n/*0:01*/+1 {
  rule #0: accum n::int (x,xs) = accum (n+1) xs
  rule #1: accum n::int x = n+1
  state 0: #0 #1
	<var>::int state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
(x/*0:0101*/,xs/*0:011*/)!n/*0:1*/::int = throw out_of_bounds if n/*0:1*/<0;
(x/*0:0101*/,xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/,y/*0:01101*/,xs/*0:0111*/)!n/*0:1*/::int = (y/*0:01101*/,xs/*0:0111*/)!(n/*0:1*/-1);
(x/*0:0101*/,y/*0:011*/)!1 = y/*0:011*/;
reverse () = ();
reverse (x/*0:101*/,xs/*0:11*/) = accum/*0*/ x/*0:101*/ xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = x/*0:1*/,ys/*0:01*/ {
  rule #0: accum ys (x,xs) = accum (x,ys) xs
  rule #1: accum ys x = x,ys
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
[]==[] = 1;
x/*0:0101*/:xs/*0:011*/==[] = 0;
[]==x/*0:101*/:xs/*0:11*/ = 0;
x/*0:0101*/:xs/*0:011*/==y/*0:101*/:ys/*0:11*/ = if x/*0:0101*/==y/*0:101*/ then xs/*0:011*/==ys/*0:11*/ else 1;
[]!=[] = 0;
x/*0:0101*/:xs/*0:011*/!=[] = 1;
[]!=x/*0:101*/:xs/*0:11*/ = 1;
x/*0:0101*/:xs/*0:011*/!=y/*0:101*/:ys/*0:11*/ = if x/*0:0101*/!=y/*0:101*/ then 1 else xs/*0:011*/!=ys/*0:11*/;
null [] = 1;
null (x/*0:101*/:xs/*0:11*/) = 0;
#[] = 0;
#(x/*0:101*/:xs/*0:11*/) = accum/*0*/ 1 xs/*0:11*/ with accum n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (n/*0:01*/+1) xs/*0:11*/; accum n/*0:01*/::int [] = n/*0:01*/; accum n/*0:01*/::int xs/*0:1*/ = n/*0:01*/+#xs/*0:1*/ {
  rule #0: accum n::int (x:xs) = accum (n+1) xs
  rule #1: accum n::int [] = n
  rule #2: accum n::int xs = n+#xs
  state 0: #0 #1 #2
	<var>::int state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
(x/*0:0101*/,xs/*0:011*/)!n/*0:1*/::int = throw out_of_bounds if n/*0:1*/<0;
(x/*0:0101*/:xs/*0:011*/)!0 = x/*0:0101*/;
(x/*0:0101*/:xs/*0:011*/)!n/*0:1*/::int = xs/*0:011*/!(n/*0:1*/-1);
[]!n/*0:1*/::int = throw out_of_bounds;
[]+ys/*0:1*/ = ys/*0:1*/;
(x/*0:0101*/:xs/*0:011*/)+ys/*0:1*/ = x/*0:0101*/:accum/*0*/ ys/*0:1*/ (reverse xs/*0:011*/) with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = ys/*0:01*/ {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = ys
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<app> state 2
	[] state 7
  state 2: #0
	<app> state 3
  state 3: #0
	: state 4
  state 4: #0
	<var> state 5
  state 5: #0
	<var> state 6
  state 6: #0
  state 7: #1
} end;
reverse [] = [];
reverse (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = ys/*0:01*/; accum _/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys (x:xs) = accum (x:ys) xs
  rule #1: accum ys [] = ys
  rule #2: accum _ xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
list () = [];
list (x/*0:101*/,xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/,xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ x/*0:1*/ = reverse (x/*0:1*/:ys/*0:01*/) {
  rule #0: accum ys (x,xs) = accum (x:ys) xs
  rule #1: accum ys x = reverse (x:ys)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 3
  state 2: #1
  state 3: #0 #1
	<var> state 4
	<app> state 6
  state 4: #1
	<var> state 5
  state 5: #1
  state 6: #0 #1
	<var> state 7
	, state 10
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
  state 11: #0 #1
	<var> state 12
  state 12: #0 #1
} end;
tuple [] = ();
tuple (x/*0:101*/:xs/*0:11*/) = accum/*0*/ x/*0:101*/ xs/*0:11*/ with accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/,ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ [] = if tuplep ys/*0:01*/ then reverse ys/*0:01*/ else ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = ys/*0:01*/,xs/*0:1*/ {
  rule #0: accum ys (x:xs) = accum (x,ys) xs
  rule #1: accum ys [] = if tuplep ys then reverse ys else ys
  rule #2: accum ys xs = ys,xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	<app> state 3
	[] state 13
  state 2: #2
  state 3: #0 #2
	<var> state 4
	<app> state 6
  state 4: #2
	<var> state 5
  state 5: #2
  state 6: #0 #2
	<var> state 7
	: state 10
  state 7: #2
	<var> state 8
  state 8: #2
	<var> state 9
  state 9: #2
  state 10: #0 #2
	<var> state 11
  state 11: #0 #2
	<var> state 12
  state 12: #0 #2
  state 13: #1 #2
} end;
xs/*0:01*/![] = [];
xs/*0:01*/!(n/*0:101*/:ns/*0:11*/) = accum/*0*/ [] (n/*1:101*/:ns/*1:11*/) with accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ (n/*0:101*/::int:ns/*0:11*/) = accum/*1*/ (xs/*2:01*/!n/*0:101*/:ys/*0:01*/) ns/*0:11*/ if n/*0:101*/>=0&&n/*0:101*/<m/*1:*/; accum ys/*0:01*/ (n/*0:101*/::int:ns/*0:11*/) = accum/*1*/ ys/*0:01*/ ns/*0:11*/; accum ys/*0:01*/ (n/*0:101*/:ns/*0:11*/) = accum/*1*/ (xs/*2:01*/!n/*0:101*/:ys/*0:01*/) ns/*0:11*/ if n/*0:101*/>=0&&n/*0:101*/<m/*1:*/; accum ys/*0:01*/ (n/*0:101*/:ns/*0:11*/) = accum/*1*/ ys/*0:01*/ ns/*0:11*/; accum ys/*0:01*/ ns/*0:1*/ = reverse ys/*0:01*/+xs/*2:01*/!ns/*0:1*/ {
  rule #0: accum ys [] = reverse ys
  rule #1: accum ys (n::int:ns) = accum (xs!n:ys) ns if n>=0&&n<m
  rule #2: accum ys (n::int:ns) = accum ys ns
  rule #3: accum ys (n:ns) = accum (xs!n:ys) ns if n>=0&&n<m
  rule #4: accum ys (n:ns) = accum ys ns
  rule #5: accum ys ns = reverse ys+xs!ns
  state 0: #0 #1 #2 #3 #4 #5
	<var> state 1
  state 1: #0 #1 #2 #3 #4 #5
	<var> state 2
	[] state 3
	<app> state 4
  state 2: #5
  state 3: #0 #5
  state 4: #1 #2 #3 #4 #5
	<var> state 5
	<app> state 7
  state 5: #5
	<var> state 6
  state 6: #5
  state 7: #1 #2 #3 #4 #5
	<var> state 8
	: state 11
  state 8: #5
	<var> state 9
  state 9: #5
	<var> state 10
  state 10: #5
  state 11: #1 #2 #3 #4 #5
	<var> state 12
	<var>::int state 14
  state 12: #3 #4 #5
	<var> state 13
  state 13: #3 #4 #5
  state 14: #1 #2 #3 #4 #5
	<var> state 15
  state 15: #1 #2 #3 #4 #5
} end when m/*0:*/::int = #xs/*0:01*/ {
  rule #0: m::int = #xs
  state 0: #0
	<var>::int state 1
  state 1: #0
} end;
n1/*0:0101*/,n2/*0:011*/..m/*0:1*/ = while (\i/*0:*/ -> s/*1:*/*i/*0:*/<=s/*1:*/*m/*3:1*/ {
  rule #0: i = s*i<=s*m
  state 0: #0
	<var> state 1
  state 1: #0
}) (\x/*0:*/ -> x/*0:*/+k/*2:*/ {
  rule #0: x = x+k
  state 0: #0
	<var> state 1
  state 1: #0
}) n1/*2:0101*/ when k/*0:*/ = n2/*0:011*/-n1/*0:0101*/; s/*0:*/ = if k/*0:*/>0 then 1 else -1 {
  rule #0: s = if k>0 then 1 else -1
  state 0: #0
	<var> state 1
  state 1: #0
} {
  rule #0: k = n2-n1
  state 0: #0
	<var> state 1
  state 1: #0
} end if n1/*0:0101*/!=n2/*0:011*/;
n/*0:01*/..m/*0:1*/ = while (\i/*0:*/ -> i/*0:*/<=m/*1:1*/ {
  rule #0: i = i<=m
  state 0: #0
	<var> state 1
  state 1: #0
}) (\x/*0:*/ -> x/*0:*/+1 {
  rule #0: x = x+1
  state 0: #0
	<var> state 1
  state 1: #0
}) n/*0:01*/;
all p/*0:01*/ [] = 1;
all p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = if p/*0:01*/ x/*0:101*/ then all p/*0:01*/ xs/*0:11*/ else 0;
any p/*0:01*/ [] = 0;
any p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = if p/*0:01*/ x/*0:101*/ then 1 else any p/*0:01*/ xs/*0:11*/;
do f/*0:01*/ [] = ();
do f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = do f/*1:01*/ xs/*1:11*/ when _/*0:*/ = f/*0:01*/ x/*0:101*/ {
  rule #0: _ = f x
  state 0: #0
	<var> state 1
  state 1: #0
} end;
drop n/*0:01*/::int [] = [];
drop n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = drop (n/*0:01*/-1) xs/*0:11*/ if n/*0:01*/>0;
drop n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:xs/*0:11*/;
dropwhile p/*0:01*/ [] = [];
dropwhile p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = dropwhile p/*0:01*/ xs/*0:11*/ if p/*0:01*/ x/*0:101*/;
dropwhile p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = x/*0:101*/:xs/*0:11*/;
filter p/*0:01*/ [] = [];
filter p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] (x/*0:101*/:xs/*0:11*/) with accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/ if p/*1:01*/ x/*0:101*/; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ ys/*0:01*/ xs/*0:11*/; accum ys/*0:01*/ xs/*0:1*/ = reverse ys/*0:01*/+filter p/*1:01*/ xs/*0:1*/ {
  rule #0: accum ys [] = reverse ys
  rule #1: accum ys (x:xs) = accum (x:ys) xs if p x
  rule #2: accum ys (x:xs) = accum ys xs
  rule #3: accum ys xs = reverse ys+filter p xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	[] state 3
	<app> state 4
  state 2: #3
  state 3: #0 #3
  state 4: #1 #2 #3
	<var> state 5
	<app> state 7
  state 5: #3
	<var> state 6
  state 6: #3
  state 7: #1 #2 #3
	<var> state 8
	: state 11
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #1 #2 #3
	<var> state 12
  state 12: #1 #2 #3
	<var> state 13
  state 13: #1 #2 #3
} end;
foldl f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldl f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:001*/ (f/*0:001*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/;
foldl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = foldl f/*0:01*/ x/*0:101*/ xs/*0:11*/;
foldr f/*0:001*/ a/*0:01*/ [] = a/*0:01*/;
foldr f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*0:001*/ x/*0:101*/ (foldl (flip f/*0:001*/) a/*0:01*/ (reverse xs/*0:11*/));
foldr1 f/*0:01*/ [x/*0:101*/] = x/*0:101*/;
foldr1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*0:01*/ x/*0:101*/ (foldl1 (flip f/*0:01*/) (reverse xs/*0:11*/));
head (x/*0:101*/:xs/*0:11*/) = x/*0:101*/;
init [x/*0:101*/] = [];
init (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ xs/*0:1*/ = reverse ys/*0:01*/+init xs/*0:1*/ {
  rule #0: accum ys [] = reverse ys
  rule #1: accum ys (x:xs) = accum (x:ys) xs
  rule #2: accum ys xs = reverse ys+init xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	[] state 3
	<app> state 4
  state 2: #2
  state 3: #0 #2
  state 4: #1 #2
	<var> state 5
	<app> state 7
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 11
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
  state 11: #1 #2
	<var> state 12
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
} end;
last [x/*0:101*/] = x/*0:101*/;
last (x/*0:101*/:xs/*0:11*/) = last xs/*0:11*/;
map f/*0:01*/ [] = [];
map f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [f/*0:01*/ x/*0:101*/] xs/*0:11*/ with accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (f/*1:01*/ x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum ys/*0:01*/ xs/*0:1*/ = reverse ys/*0:01*/+map f/*1:01*/ xs/*0:1*/ {
  rule #0: accum ys [] = reverse ys
  rule #1: accum ys (x:xs) = accum (f x:ys) xs
  rule #2: accum ys xs = reverse ys+map f xs
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
	[] state 3
	<app> state 4
  state 2: #2
  state 3: #0 #2
  state 4: #1 #2
	<var> state 5
	<app> state 7
  state 5: #2
	<var> state 6
  state 6: #2
  state 7: #1 #2
	<var> state 8
	: state 11
  state 8: #2
	<var> state 9
  state 9: #2
	<var> state 10
  state 10: #2
  state 11: #1 #2
	<var> state 12
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
} end;
scanl f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanl f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [a/*0:01*/] (f/*0:001*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/ with accum ys/*0:001*/ a/*0:01*/ [] = reverse (a/*0:01*/:ys/*0:001*/); accum ys/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (a/*0:01*/:ys/*0:001*/) (f/*1:001*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/; accum _/*0:001*/ _/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys a [] = reverse (a:ys)
  rule #1: accum ys a (x:xs) = accum (a:ys) (f a x) xs
  rule #2: accum _ _ xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
	[] state 4
	<app> state 5
  state 3: #2
  state 4: #0 #2
  state 5: #1 #2
	<var> state 6
	<app> state 8
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1 #2
	<var> state 9
	: state 12
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
} end;
scanl1 f/*0:01*/ [] = [];
scanl1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] x/*0:101*/ xs/*0:11*/ with accum ys/*0:001*/ a/*0:01*/ [] = reverse (a/*0:01*/:ys/*0:001*/); accum ys/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (a/*0:01*/:ys/*0:001*/) (f/*1:01*/ a/*0:01*/ x/*0:101*/) xs/*0:11*/; accum _/*0:001*/ _/*0:01*/ xs/*0:1*/ = throw (bad_list_value xs/*0:1*/) {
  rule #0: accum ys a [] = reverse (a:ys)
  rule #1: accum ys a (x:xs) = accum (a:ys) (f a x) xs
  rule #2: accum _ _ xs = throw (bad_list_value xs)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
	[] state 4
	<app> state 5
  state 3: #2
  state 4: #0 #2
  state 5: #1 #2
	<var> state 6
	<app> state 8
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1 #2
	<var> state 9
	: state 12
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
  state 13: #1 #2
	<var> state 14
  state 14: #1 #2
} end;
scanr f/*0:001*/ a/*0:01*/ [] = [a/*0:01*/];
scanr f/*0:001*/ a/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*2:001*/ x/*2:101*/ y/*0:01*/:ys/*1:*/ when ys/*0:*/ = reverse (scanl (flip f/*0:001*/) a/*0:01*/ (reverse xs/*0:11*/)); y/*0:01*/:_/*0:1*/ = ys/*0:*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} {
  rule #0: ys = reverse (scanl (flip f) a (reverse xs))
  state 0: #0
	<var> state 1
  state 1: #0
} end;
scanr1 f/*0:01*/ [] = [];
scanr1 f/*0:01*/ [x/*0:101*/] = [x/*0:101*/];
scanr1 f/*0:01*/ (x/*0:101*/:xs/*0:11*/) = f/*2:01*/ x/*2:101*/ y/*0:01*/:ys/*1:*/ when ys/*0:*/ = reverse (scanl1 (flip f/*0:01*/) (reverse xs/*0:11*/)); y/*0:01*/:_/*0:1*/ = ys/*0:*/ {
  rule #0: y:_ = ys
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	: state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} {
  rule #0: ys = reverse (scanl1 (flip f) (reverse xs))
  state 0: #0
	<var> state 1
  state 1: #0
} end;
tail (x/*0:101*/:xs/*0:11*/) = xs/*0:11*/;
take n/*0:01*/::int [] = [];
take n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = accum/*0*/ n/*0:01*/ [] (x/*0:101*/:xs/*0:11*/) with accum _/*0:001*/ ys/*0:01*/ [] = reverse ys/*0:01*/; accum n/*0:001*/::int ys/*0:01*/ _/*0:1*/ = reverse ys/*0:01*/ if n/*0:001*/<=0; accum n/*0:001*/::int ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (n/*0:001*/-1) (x/*0:101*/:ys/*0:01*/) xs/*0:11*/; accum n/*0:001*/ ys/*0:01*/ xs/*0:1*/ = reverse ys/*0:01*/+take n/*0:001*/ xs/*0:1*/ {
  rule #0: accum _ ys [] = reverse ys
  rule #1: accum n::int ys _ = reverse ys if n<=0
  rule #2: accum n::int ys (x:xs) = accum (n-1) (x:ys) xs
  rule #3: accum n ys xs = reverse ys+take n xs
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::int state 5
  state 1: #0 #3
	<var> state 2
  state 2: #0 #3
	<var> state 3
	[] state 4
  state 3: #3
  state 4: #0 #3
  state 5: #0 #1 #2 #3
	<var> state 6
  state 6: #0 #1 #2 #3
	<var> state 7
	[] state 8
	<app> state 9
  state 7: #1 #3
  state 8: #0 #1 #3
  state 9: #1 #2 #3
	<var> state 10
	<app> state 12
  state 10: #1 #3
	<var> state 11
  state 11: #1 #3
  state 12: #1 #2 #3
	<var> state 13
	: state 16
  state 13: #1 #3
	<var> state 14
  state 14: #1 #3
	<var> state 15
  state 15: #1 #3
  state 16: #1 #2 #3
	<var> state 17
  state 17: #1 #2 #3
	<var> state 18
  state 18: #1 #2 #3
} end;
takewhile p/*0:01*/ [] = [];
takewhile p/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] (x/*0:101*/:xs/*0:11*/) with accum ys/*0:01*/ [] = reverse ys/*0:01*/; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = accum/*1*/ (x/*0:101*/:ys/*0:01*/) xs/*0:11*/ if p/*1:01*/ x/*0:101*/; accum ys/*0:01*/ (x/*0:101*/:xs/*0:11*/) = reverse ys/*0:01*/; accum ys/*0:01*/ xs/*0:1*/ = reverse ys/*0:01*/+takewhile p/*1:01*/ xs/*0:1*/ {
  rule #0: accum ys [] = reverse ys
  rule #1: accum ys (x:xs) = accum (x:ys) xs if p x
  rule #2: accum ys (x:xs) = reverse ys
  rule #3: accum ys xs = reverse ys+takewhile p xs
  state 0: #0 #1 #2 #3
	<var> state 1
  state 1: #0 #1 #2 #3
	<var> state 2
	[] state 3
	<app> state 4
  state 2: #3
  state 3: #0 #3
  state 4: #1 #2 #3
	<var> state 5
	<app> state 7
  state 5: #3
	<var> state 6
  state 6: #3
  state 7: #1 #2 #3
	<var> state 8
	: state 11
  state 8: #3
	<var> state 9
  state 9: #3
	<var> state 10
  state 10: #3
  state 11: #1 #2 #3
	<var> state 12
  state 12: #1 #2 #3
	<var> state 13
  state 13: #1 #2 #3
} end;
cat [] = [];
cat [xs/*0:101*/] = xs/*0:101*/;
cat (xs/*0:101*/:xss/*0:11*/) = accum/*0*/ (reverse xs/*0:101*/) xss/*0:11*/ with accum xs/*0:01*/ [] = reverse xs/*0:01*/; accum xs/*0:01*/ ([]:yss/*0:11*/) = accum/*1*/ xs/*0:01*/ yss/*0:11*/; accum xs/*0:01*/ ((y/*0:10101*/:ys/*0:1011*/):yss/*0:11*/) = accum/*1*/ (y/*0:10101*/:xs/*0:01*/) (ys/*0:1011*/:yss/*0:11*/); accum _/*0:01*/ (ys/*0:101*/:_/*0:11*/) = throw (bad_list_value ys/*0:101*/); accum _/*0:01*/ yss/*0:1*/ = throw (bad_list_value yss/*0:1*/) {
  rule #0: accum xs [] = reverse xs
  rule #1: accum xs ([]:yss) = accum xs yss
  rule #2: accum xs ((y:ys):yss) = accum (y:xs) (ys:yss)
  rule #3: accum _ (ys:_) = throw (bad_list_value ys)
  rule #4: accum _ yss = throw (bad_list_value yss)
  state 0: #0 #1 #2 #3 #4
	<var> state 1
  state 1: #0 #1 #2 #3 #4
	<var> state 2
	[] state 3
	<app> state 4
  state 2: #4
  state 3: #0 #4
  state 4: #1 #2 #3 #4
	<var> state 5
	<app> state 7
  state 5: #4
	<var> state 6
  state 6: #4
  state 7: #1 #2 #3 #4
	<var> state 8
	: state 11
  state 8: #4
	<var> state 9
  state 9: #4
	<var> state 10
  state 10: #4
  state 11: #1 #2 #3 #4
	<var> state 12
	[] state 14
	<app> state 16
  state 12: #3 #4
	<var> state 13
  state 13: #3 #4
  state 14: #1 #3 #4
	<var> state 15
  state 15: #1 #3 #4
  state 16: #2 #3 #4
	<var> state 17
	<app> state 20
  state 17: #3 #4
	<var> state 18
  state 18: #3 #4
	<var> state 19
  state 19: #3 #4
  state 20: #2 #3 #4
	<var> state 21
	: state 25
  state 21: #3 #4
	<var> state 22
  state 22: #3 #4
	<var> state 23
  state 23: #3 #4
	<var> state 24
  state 24: #3 #4
  state 25: #2 #3 #4
	<var> state 26
  state 26: #2 #3 #4
	<var> state 27
  state 27: #2 #3 #4
	<var> state 28
  state 28: #2 #3 #4
} end;
catmap f/*0:01*/ xs/*0:1*/ = cat (map f/*0:01*/ xs/*0:1*/);
index [] _/*0:1*/ = -1;
index (x/*0:0101*/:xs/*0:011*/) y/*0:1*/ = search/*0*/ 0 (x/*0:0101*/:xs/*0:011*/) with search _/*0:01*/ [] = -1; search n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = n/*0:01*/ if x/*0:101*/==y/*1:1*/; search n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = search/*1*/ (n/*0:01*/+1) xs/*0:11*/; search _/*0:01*/ xs/*0:1*/ = index xs/*0:1*/ y/*1:1*/ {
  rule #0: search _ [] = -1
  rule #1: search n::int (x:xs) = n if x==y
  rule #2: search n::int (x:xs) = search (n+1) xs
  rule #3: search _ xs = index xs y
  state 0: #0 #1 #2 #3
	<var> state 1
	<var>::int state 4
  state 1: #0 #3
	<var> state 2
	[] state 3
  state 2: #3
  state 3: #0 #3
  state 4: #0 #1 #2 #3
	<var> state 5
	[] state 6
	<app> state 7
  state 5: #3
  state 6: #0 #3
  state 7: #1 #2 #3
	<var> state 8
	<app> state 10
  state 8: #3
	<var> state 9
  state 9: #3
  state 10: #1 #2 #3
	<var> state 11
	: state 14
  state 11: #3
	<var> state 12
  state 12: #3
	<var> state 13
  state 13: #3
  state 14: #1 #2 #3
	<var> state 15
  state 15: #1 #2 #3
	<var> state 16
  state 16: #1 #2 #3
} end;
repeat n/*0:01*/::int x/*0:1*/ = accum/*0*/ [] n/*0:01*/ x/*0:1*/ with accum xs/*0:001*/ n/*0:01*/::int x/*0:1*/ = xs/*0:001*/ if n/*0:01*/<=0; accum xs/*0:001*/ n/*0:01*/::int x/*0:1*/ = accum/*1*/ (x/*0:1*/:xs/*0:001*/) (n/*0:01*/-1) x/*0:1*/ {
  rule #0: accum xs n::int x = xs if n<=0
  rule #1: accum xs n::int x = accum (x:xs) (n-1) x
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
} end;
cycle n/*0:01*/::int [] = [];
cycle n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = [] if n/*0:01*/<=0;
cycle n/*0:01*/::int (x/*0:101*/:xs/*0:11*/) = accum/*0*/ [] n/*2:01*/ with accum ys/*0:01*/ n/*0:1*/::int = cat ys/*0:01*/+take n/*0:1*/ xs/*2:*/ if n/*0:1*/<=m/*1:*/; accum ys/*0:01*/ n/*0:1*/::int = accum/*1*/ (xs/*2:*/:ys/*0:01*/) (n/*0:1*/-m/*1:*/) {
  rule #0: accum ys n::int = cat ys+take n xs if n<=m
  rule #1: accum ys n::int = accum (xs:ys) (n-m)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var>::int state 2
  state 2: #0 #1
} end when xs/*0:*/ = x/*0:101*/:xs/*0:11*/; m/*0:*/::int = #xs/*0:*/ {
  rule #0: m::int = #xs
  state 0: #0
	<var>::int state 1
  state 1: #0
} {
  rule #0: xs = x:xs
  state 0: #0
	<var> state 1
  state 1: #0
} end if listp xs/*0:11*/;
while p/*0:001*/ f/*0:01*/ a/*0:1*/ = accum/*0*/ [] p/*0:001*/ f/*0:01*/ a/*0:1*/ with accum as/*0:0001*/ p/*0:001*/ f/*0:01*/ a/*0:1*/ = accum/*1*/ (a/*0:1*/:as/*0:0001*/) p/*0:001*/ f/*0:01*/ (f/*0:01*/ a/*0:1*/) if p/*0:001*/ a/*0:1*/; accum as/*0:0001*/ p/*0:001*/ f/*0:01*/ a/*0:1*/ = reverse as/*0:0001*/ {
  rule #0: accum as p f a = accum (a:as) p f (f a) if p a
  rule #1: accum as p f a = reverse as
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
until p/*0:001*/ f/*0:01*/ a/*0:1*/ = accum/*0*/ [] p/*0:001*/ f/*0:01*/ a/*0:1*/ with accum as/*0:0001*/ p/*0:001*/ f/*0:01*/ a/*0:1*/ = reverse as/*0:0001*/ if p/*0:001*/ a/*0:1*/; accum as/*0:0001*/ p/*0:001*/ f/*0:01*/ a/*0:1*/ = accum/*1*/ (a/*0:1*/:as/*0:0001*/) p/*0:001*/ f/*0:01*/ (f/*0:01*/ a/*0:1*/) {
  rule #0: accum as p f a = reverse as if p a
  rule #1: accum as p f a = accum (a:as) p f (f a)
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
  state 2: #0 #1
	<var> state 3
  state 3: #0 #1
	<var> state 4
  state 4: #0 #1
} end;
zip xs/*0:01*/ ys/*0:1*/ = accum/*0*/ [] xs/*0:01*/ ys/*0:1*/ with accum us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = accum/*1*/ ((x/*0:0101*/,y/*0:101*/):us/*0:001*/) xs/*0:011*/ ys/*0:11*/; accum us/*0:001*/ _/*0:01*/ _/*0:1*/ = reverse us/*0:001*/ {
  rule #0: accum us (x:xs) (y:ys) = accum ((x,y):us) xs ys
  rule #1: accum us _ _ = reverse us
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 4
  state 2: #1
	<var> state 3
  state 3: #1
  state 4: #0 #1
	<var> state 5
	<app> state 8
  state 5: #1
	<var> state 6
  state 6: #1
	<var> state 7
  state 7: #1
  state 8: #0 #1
	<var> state 9
	: state 13
  state 9: #1
	<var> state 10
  state 10: #1
	<var> state 11
  state 11: #1
	<var> state 12
  state 12: #1
  state 13: #0 #1
	<var> state 14
  state 14: #0 #1
	<var> state 15
  state 15: #0 #1
	<var> state 16
	<app> state 17
  state 16: #1
  state 17: #0 #1
	<var> state 18
	<app> state 20
  state 18: #1
	<var> state 19
  state 19: #1
  state 20: #0 #1
	<var> state 21
	: state 24
  state 21: #1
	<var> state 22
  state 22: #1
	<var> state 23
  state 23: #1
  state 24: #0 #1
	<var> state 25
  state 25: #0 #1
	<var> state 26
  state 26: #0 #1
} end;
zip3 xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = accum/*0*/ [] xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with accum us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = accum/*1*/ ((x/*0:00101*/,y/*0:0101*/,z/*0:101*/):us/*0:0001*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; accum us/*0:0001*/ _/*0:001*/ _/*0:01*/ _/*0:1*/ = reverse us/*0:0001*/ {
  rule #0: accum us (x:xs) (y:ys) (z:zs) = accum ((x,y,z):us) xs ys zs
  rule #1: accum us _ _ _ = reverse us
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 5
  state 2: #1
	<var> state 3
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	<app> state 10
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
	: state 16
  state 11: #1
	<var> state 12
  state 12: #1
	<var> state 13
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
	<var> state 19
	<app> state 21
  state 19: #1
	<var> state 20
  state 20: #1
  state 21: #0 #1
	<var> state 22
	<app> state 25
  state 22: #1
	<var> state 23
  state 23: #1
	<var> state 24
  state 24: #1
  state 25: #0 #1
	<var> state 26
	: state 30
  state 26: #1
	<var> state 27
  state 27: #1
	<var> state 28
  state 28: #1
	<var> state 29
  state 29: #1
  state 30: #0 #1
	<var> state 31
  state 31: #0 #1
	<var> state 32
  state 32: #0 #1
	<var> state 33
	<app> state 34
  state 33: #1
  state 34: #0 #1
	<var> state 35
	<app> state 37
  state 35: #1
	<var> state 36
  state 36: #1
  state 37: #0 #1
	<var> state 38
	: state 41
  state 38: #1
	<var> state 39
  state 39: #1
	<var> state 40
  state 40: #1
  state 41: #0 #1
	<var> state 42
  state 42: #0 #1
	<var> state 43
  state 43: #0 #1
} end;
zipwith f/*0:001*/ xs/*0:01*/ ys/*0:1*/ = accum/*0*/ [] xs/*0:01*/ ys/*0:1*/ with accum us/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = accum/*1*/ (f/*1:001*/ x/*0:0101*/ y/*0:101*/:us/*0:001*/) xs/*0:011*/ ys/*0:11*/; accum us/*0:001*/ _/*0:01*/ _/*0:1*/ = reverse us/*0:001*/ {
  rule #0: accum us (x:xs) (y:ys) = accum (f x y:us) xs ys
  rule #1: accum us _ _ = reverse us
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 4
  state 2: #1
	<var> state 3
  state 3: #1
  state 4: #0 #1
	<var> state 5
	<app> state 8
  state 5: #1
	<var> state 6
  state 6: #1
	<var> state 7
  state 7: #1
  state 8: #0 #1
	<var> state 9
	: state 13
  state 9: #1
	<var> state 10
  state 10: #1
	<var> state 11
  state 11: #1
	<var> state 12
  state 12: #1
  state 13: #0 #1
	<var> state 14
  state 14: #0 #1
	<var> state 15
  state 15: #0 #1
	<var> state 16
	<app> state 17
  state 16: #1
  state 17: #0 #1
	<var> state 18
	<app> state 20
  state 18: #1
	<var> state 19
  state 19: #1
  state 20: #0 #1
	<var> state 21
	: state 24
  state 21: #1
	<var> state 22
  state 22: #1
	<var> state 23
  state 23: #1
  state 24: #0 #1
	<var> state 25
  state 25: #0 #1
	<var> state 26
  state 26: #0 #1
} end;
zipwith3 f/*0:0001*/ xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ = accum/*0*/ [] xs/*0:001*/ ys/*0:01*/ zs/*0:1*/ with accum us/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = accum/*1*/ (f/*1:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/:us/*0:0001*/) xs/*0:0011*/ ys/*0:011*/ zs/*0:11*/; accum us/*0:0001*/ _/*0:001*/ _/*0:01*/ _/*0:1*/ = reverse us/*0:0001*/ {
  rule #0: accum us (x:xs) (y:ys) (z:zs) = accum (f x y z:us) xs ys zs
  rule #1: accum us _ _ _ = reverse us
  state 0: #0 #1
	<var> state 1
  state 1: #0 #1
	<var> state 2
	<app> state 5
  state 2: #1
	<var> state 3
  state 3: #1
	<var> state 4
  state 4: #1
  state 5: #0 #1
	<var> state 6
	<app> state 10
  state 6: #1
	<var> state 7
  state 7: #1
	<var> state 8
  state 8: #1
	<var> state 9
  state 9: #1
  state 10: #0 #1
	<var> state 11
	: state 16
  state 11: #1
	<var> state 12
  state 12: #1
	<var> state 13
  state 13: #1
	<var> state 14
  state 14: #1
	<var> state 15
  state 15: #1
  state 16: #0 #1
	<var> state 17
  state 17: #0 #1
	<var> state 18
  state 18: #0 #1
	<var> state 19
	<app> state 21
  state 19: #1
	<var> state 20
  state 20: #1
  state 21: #0 #1
	<var> state 22
	<app> state 25
  state 22: #1
	<var> state 23
  state 23: #1
	<var> state 24
  state 24: #1
  state 25: #0 #1
	<var> state 26
	: state 30
  state 26: #1
	<var> state 27
  state 27: #1
	<var> state 28
  state 28: #1
	<var> state 29
  state 29: #1
  state 30: #0 #1
	<var> state 31
  state 31: #0 #1
	<var> state 32
  state 32: #0 #1
	<var> state 33
	<app> state 34
  state 33: #1
  state 34: #0 #1
	<var> state 35
	<app> state 37
  state 35: #1
	<var> state 36
  state 36: #1
  state 37: #0 #1
	<var> state 38
	: state 41
  state 38: #1
	<var> state 39
  state 39: #1
	<var> state 40
  state 40: #1
  state 41: #0 #1
	<var> state 42
  state 42: #0 #1
	<var> state 43
  state 43: #0 #1
} end;
dowith f/*0:001*/ (x/*0:0101*/:xs/*0:011*/) (y/*0:101*/:ys/*0:11*/) = dowith f/*1:001*/ xs/*1:011*/ ys/*1:11*/ when _/*0:*/ = f/*0:001*/ x/*0:0101*/ y/*0:101*/ {
  rule #0: _ = f x y
  state 0: #0
	<var> state 1
  state 1: #0
} end;
dowith f/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
dowith3 f/*0:0001*/ (x/*0:00101*/:xs/*0:0011*/) (y/*0:0101*/:ys/*0:011*/) (z/*0:101*/:zs/*0:11*/) = dowith3 f/*1:0001*/ xs/*1:0011*/ ys/*1:011*/ zs/*1:11*/ when _/*0:*/ = f/*0:0001*/ x/*0:00101*/ y/*0:0101*/ z/*0:101*/ {
  rule #0: _ = f x y z
  state 0: #0
	<var> state 1
  state 1: #0
} end;
dowith3 f/*0:0001*/ _/*0:001*/ _/*0:01*/ _/*0:1*/ = ();
unzip [] = [],[];
unzip ((x/*0:10101*/,y/*0:1011*/):us/*0:11*/) = x/*1:10101*/:xs/*0:01*/,y/*1:1011*/:ys/*0:1*/ when xs/*0:01*/,ys/*0:1*/ = accum/*0*/ [] [] us/*0:11*/ {
  rule #0: xs,ys = accum [] [] us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<var> state 5
  state 5: #0
} end with accum xs/*0:001*/ ys/*0:01*/ [] = reverse xs/*0:001*/,reverse ys/*0:01*/; accum xs/*0:001*/ ys/*0:01*/ ((x/*0:10101*/,y/*0:1011*/):us/*0:11*/) = accum/*1*/ (x/*0:10101*/:xs/*0:001*/) (y/*0:1011*/:ys/*0:01*/) us/*0:11*/; accum _/*0:001*/ _/*0:01*/ us/*0:1*/ = throw (bad_list_value us/*0:1*/) {
  rule #0: accum xs ys [] = reverse xs,reverse ys
  rule #1: accum xs ys ((x,y):us) = accum (x:xs) (y:ys) us
  rule #2: accum _ _ us = throw (bad_list_value us)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
	[] state 4
	<app> state 5
  state 3: #2
  state 4: #0 #2
  state 5: #1 #2
	<var> state 6
	<app> state 8
  state 6: #2
	<var> state 7
  state 7: #2
  state 8: #1 #2
	<var> state 9
	: state 12
  state 9: #2
	<var> state 10
  state 10: #2
	<var> state 11
  state 11: #2
  state 12: #1 #2
	<var> state 13
	<app> state 15
  state 13: #2
	<var> state 14
  state 14: #2
  state 15: #1 #2
	<var> state 16
	<app> state 19
  state 16: #2
	<var> state 17
  state 17: #2
	<var> state 18
  state 18: #2
  state 19: #1 #2
	<var> state 20
	, state 24
  state 20: #2
	<var> state 21
  state 21: #2
	<var> state 22
  state 22: #2
	<var> state 23
  state 23: #2
  state 24: #1 #2
	<var> state 25
  state 25: #1 #2
	<var> state 26
  state 26: #1 #2
	<var> state 27
  state 27: #1 #2
} end;
unzip3 [] = [],[],[];
unzip3 ((x/*0:10101*/,y/*0:101101*/,z/*0:10111*/):us/*0:11*/) = x/*1:10101*/:xs/*0:01*/,y/*1:101101*/:ys/*0:101*/,z/*1:10111*/:zs/*0:11*/ when xs/*0:01*/,ys/*0:101*/,zs/*0:11*/ = accum/*0*/ [] [] [] us/*0:11*/ {
  rule #0: xs,ys,zs = accum [] [] [] us
  state 0: #0
	<app> state 1
  state 1: #0
	<app> state 2
  state 2: #0
	, state 3
  state 3: #0
	<var> state 4
  state 4: #0
	<app> state 5
  state 5: #0
	<app> state 6
  state 6: #0
	, state 7
  state 7: #0
	<var> state 8
  state 8: #0
	<var> state 9
  state 9: #0
} end with accum xs/*0:0001*/ ys/*0:001*/ zs/*0:01*/ [] = reverse xs/*0:0001*/,reverse ys/*0:001*/,reverse zs/*0:01*/; accum xs/*0:0001*/ ys/*0:001*/ zs/*0:01*/ ((x/*0:10101*/,y/*0:101101*/,z/*0:10111*/):us/*0:11*/) = accum/*1*/ (x/*0:10101*/:xs/*0:0001*/) (y/*0:101101*/:ys/*0:001*/) (z/*0:10111*/:zs/*0:01*/) us/*0:11*/; accum _/*0:0001*/ _/*0:001*/ _/*0:01*/ us/*0:1*/ = throw (bad_list_value us/*0:1*/) {
  rule #0: accum xs ys zs [] = reverse xs,reverse ys,reverse zs
  rule #1: accum xs ys zs ((x,y,z):us) = accum (x:xs) (y:ys) (z:zs) us
  rule #2: accum _ _ _ us = throw (bad_list_value us)
  state 0: #0 #1 #2
	<var> state 1
  state 1: #0 #1 #2
	<var> state 2
  state 2: #0 #1 #2
	<var> state 3
  state 3: #0 #1 #2
	<var> state 4
	[] state 5
	<app> state 6
  state 4: #2
  state 5: #0 #2
  state 6: #1 #2
	<var> state 7
	<app> state 9
  state 7: #2
	<var> state 8
  state 8: #2
  state 9: #1 #2
	<var> state 10
	: state 13
  state 10: #2
	<var> state 11
  state 11: #2
	<var> state 12
  state 12: #2
  state 13: #1 #2
	<var> state 14
	<app> state 16
  state 14: #2
	<var> state 15
  state 15: #2
  state 16: #1 #2
	<var> state 17
	<app> state 20
  state 17: #2
	<var> state 18
  state 18: #2
	<var> state 19
  state 19: #2
  state 20: #1 #2
	<var> state 21
	, state 25
  state 21: #2
	<var> state 22
  state 22: #2
	<var> state 23
  state 23: #2
	<var> state 24
  state 24: #2
  state 25: #1 #2
	<var> state 26
  state 26: #1 #2
	<var> state 27
	<app> state 29
  state 27: #2
	<var> state 28
  state 28: #2
  state 29: #1 #2
	<var> state 30
	<app> state 33
  state 30: #2
	<var> state 31
  state 31: #2
	<var> state 32
  state 32: #2
  state 33: #1 #2
	<var> state 34
	, state 38
  state 34: #2
	<var> state 35
  state 35: #2
	<var> state 36
  state 36: #2
	<var> state 37
  state 37: #2
  state 38: #1 #2
	<var> state 39
  state 39: #1 #2
	<var> state 40
  state 40: #1 #2
	<var> state 41
  state 41: #1 #2
} end;
