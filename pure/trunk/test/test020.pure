// math.pure tests by Eddie Rucker

using math;

// unary operations

let f = [sqrt, sin, cos, tan, ln, log, exp, atan, asin, acos, sinh, cosh, tanh,
	 asinh, acosh, atanh, abs, re, im, arg, conj, rect, polar, cis, ceil, 
	 floor, round, frac, complexp, realp, rationalp, numberp, exactp, 
	 inexactp, infp, nanp];
let x = [1, -1, 0, 0.0, 1.2, -1.2, 1%3, -1%4, 1+:2, -1+:2, 1+:-2, -1.2+:4.3,
	 1.2+:-4.3, 1%2+:1, 1%2+:3%4, 3<:1, -3<:1, 3.0<:-3, 3.1<:2.5, (2%3)<:2,
	 (1%2)<:(3%4), -inf, nan];

// binary operations

let f2 = [(+), (-), (*), (/), (^), atan2, pow];
let x2 = [i,j; i=x; j=x];

// test instrumentation (AG)

using system;

/* This will print out each operation, arguments and result as a single
   line. Exceptions are flagged with '__error__', evaluation failures with
   '__failed__'. */

test f (x,y) = puts $ str (f,x,y,check f (x,y) (catch __error__ (f x y)));
test f x = puts $ str (f,x,check f x (catch __error__ (f x)));

check f (x,y) z@(f1@_ x1 y1) = __failed__ z if f===f1 && x===x1 && y===y1;
check f x z@(f1@_ x1) = __failed__ z if f===f1 && x===x1;
check _ _ z = z otherwise;

puts "*** UNARY ***" $$ void [f,x,test f x; f=f; x=x] $$
puts "*** BINARY ***" $$ void [f,x,test f x; f=f2; x=x2];
